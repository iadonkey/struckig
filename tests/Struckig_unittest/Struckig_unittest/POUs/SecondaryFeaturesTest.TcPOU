<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="SecondaryFeaturesTest" Id="{78a4d410-064c-404a-a1d2-ebb5b6bc814b}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK SecondaryFeaturesTest EXTENDS TcUnit.FB_TestSuite
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..2] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL; 
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[Test_AtTime();
Test_AtTime1();
Test_AtTime1_2();
Test_DurationDiscretization();
Test_EnabledDof();
Test_FirstStateAtTime();
Test_IndependentMinDurations();
Test_IndependentMinDurations_1();
Test_InputInitalized();
Test_InputValidation();
Test_InvalidInput();
Test_PerDofSettings();
Test_PerDofSettings_1();
Test_PhaseSynchronization();
Test_PositionExtrema();


]]></ST>
    </Implementation>
    <Method Name="Test_AtTime" Id="{8747a524-a952-4b4b-9b1d-d5709bbaaf50}">
      <Declaration><![CDATA[METHOD Test_AtTime
VAR_INST
  otg : Struckig.Otg(0.005, 3) := (
  
    Synchronization := SynchronizationType.TimeSync,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );
   
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  NewSection : INT;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
	output: INT;
	trajectory: INT;
	atTime: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('AtTime');

otg();

AssertEquals_INT(Expected := Struckig.TrajectoryState.busy, Actual := otg.State, Message := '');
AssertEquals_LREAL(4.0, otg.Duration, 1E-9, Message:='');

otg.AtTime(0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
AssertArrayEquals_LREAL(otg.CurrentPosition, NewPosition, 1E-9, message:='p(0) should be CurrentPosition');
AssertArrayEquals_LREAL(otg.CurrentVelocity, NewVelocity, 1E-9, message:='v(0) should be CurrentVelocity');
AssertArrayEquals_LREAL(otg.CurrentAcceleration, NewAcceleration, 1E-9, message:='a(0) should be CurrentAcceleration');

otg.AtTime(otg.Duration, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
AssertArrayEquals_LREAL(otg.TargetPosition, NewPosition, 1E-9, message:='p(0) should be TargetPosition');
AssertArrayEquals_LREAL(otg.TargetVelocity, NewVelocity, 1E-9, message:='v(0) should be TargetVelocity');
AssertArrayEquals_LREAL(otg.TargetAcceleration, NewAcceleration, 1E-9, message:='a(0) should be TargetAcceleration');

otg.AtTime(2.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
values[0] := 0.5;
values[1] := -2.6871268303;
values[2] := 1.0;
AssertArrayEquals_LREAL(values, NewPosition, 1E-9, message:='');

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_AtTime1" Id="{6b9a2765-c384-4cf1-ad5e-1b9d190a840a}">
      <Declaration><![CDATA[METHOD Test_AtTime1
VAR_INST
  otg : Struckig.Otg(0.005, 1) := (
    CurrentPosition :=     [ 0.0 ],
    CurrentVelocity :=     [ 0.0 ],
    CurrentAcceleration := [ 0.0 ],
    TargetPosition :=      [ 1.0 ],
    TargetVelocity :=      [ 0.0 ],
    TargetAcceleration :=  [ 0.0 ],
    MaxVelocity :=         [ 1.0 ],
    MaxAcceleration :=     [ 1.0 ],
    MaxJerk :=             [ 1.0 ],
	EnableAutoPropagate := FALSE
  ); 
END_VAR
VAR
  result : Struckig.TrajectoryState;
  newPosition, newVelocity, newAcceleration : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('AtTime1');


otg();

AssertEquals_INT(Expected := Struckig.TrajectoryState.Busy, Actual := otg.State, Message := '');
AssertEquals_LREAL(3.1748, otg.Duration, 1E-4, Message:='');

otg.AtTime1(0, newPosition, newVelocity, newAcceleration);
AssertEquals_LREAL(otg.CurrentPosition[0], newPosition, 1E-5, Message:='');

otg.AtTime1(3.1748 / 2, newPosition, newVelocity, newAcceleration);
AssertEquals_LREAL(0.5, newPosition, 1E-4, Message:='');

otg.AtTime1(3.1748, newPosition, newVelocity, newAcceleration);
AssertEquals_LREAL(1.0, newPosition, 1E-4, Message:='');
AssertEquals_LREAL(0.0, newVelocity, 1E-4, Message:='');
AssertEquals_LREAL(0.0, newAcceleration, 1E-4, Message:='');


TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_AtTime1_2" Id="{96218005-af63-4d3f-bab2-ab982daff044}">
      <Declaration><![CDATA[METHOD Test_AtTime1_2
VAR_INST
  otg : Struckig.Otg(0.005, 2) := (
    CurrentPosition :=     [ 0.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, 1.0 ],
    TargetVelocity :=      [ 0.0, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0 ],
	EnableAutoPropagate := FALSE
  ); 
END_VAR
VAR
  result : Struckig.TrajectoryState;
  newPosition, newVelocity, newAcceleration : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('AtTime1_2');


otg();

AssertEquals_INT(Expected := Struckig.TrajectoryState.Busy, Actual := otg.State, Message := '');
AssertEquals_LREAL(3.1748, otg.Duration, 1E-4, Message:='');

newPosition := 5;
otg.AtTime1(0, newPosition, newVelocity, newAcceleration);
AssertEquals_LREAL(5.0, newPosition, 1E-4, Message:='No calculation with AtTime1 if DoF != 1');

otg.AtTime1(3.1748 / 2, newPosition, newVelocity, newAcceleration);
AssertEquals_LREAL(5.0, newPosition, 1E-4, Message:='No calculation with AtTime1 if DoF != 1');

otg.AtTime1(3.1748, newPosition, newVelocity, newAcceleration);
AssertEquals_LREAL(5.0, newPosition, 1E-4, Message:='No calculation with AtTime1 if DoF != 1');


TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_DurationDiscretization" Id="{96b06b61-943e-49d9-869c-f7c2aca9f7ba}">
      <Declaration><![CDATA[METHOD Test_DurationDiscretization
VAR_INST
  otg : Struckig.Otg(0.01, 3) := (
    CurrentPosition :=     [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.2, 0.2, 0.2 ],    
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 2.0, 2.0, 2.0 ],
    MaxJerk :=             [ 1.8, 2.4, 2.0 ],
    Discretization := DiscretizationType.Discrete
  ); 
END_VAR
VAR
  result : Struckig.TrajectoryState;
  busy : Struckig.TrajectoryState := Struckig.TrajectoryState.Busy;
  NewSection : INT;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('DurationDiscretization');

otg();
result := otg.State;
AssertEquals(busy, result, Message := '');
AssertEquals_LREAL(otg.Duration, 4.5, 1E-6, Message := ''); 
otg.AtTime(4.5, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
values[0] := 1.0;
values[1] := -3.0;
values[2] := 2.0;
AssertArrayEquals_LREAL(values, NewPosition, 1E-6, '');

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_EnabledDof" Id="{214ba0d0-4f01-4d0c-830d-5b3789ab7356}">
      <Declaration><![CDATA[METHOD Test_EnabledDof
VAR_INST
  otg : Struckig.Otg(0.005, 3) := (
    Enabled := [TRUE, FALSE, FALSE],
    Synchronization := SynchronizationType.TimeSync,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.1, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, -0.2 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );
END_VAR
VAR
  result : Struckig.TrajectoryState;
  busy : Struckig.TrajectoryState := Struckig.TrajectoryState.Busy;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  NewSection : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('EnabledDof');

otg(EnableAutoPropagate := FALSE);
result := otg.State;
AssertEquals(busy, result, Message := '');
AssertEquals_LREAL(otg.Duration, 3.1748021039, 1E-6, Message := ''); 

otg.AtTime(0.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
AssertArrayEquals_LREAL(otg.CurrentPosition, NewPosition, 1E-6, '');
AssertArrayEquals_LREAL(otg.CurrentVelocity, NewVelocity, 1E-6, '');
AssertArrayEquals_LREAL(otg.CurrentAcceleration, NewAcceleration, 1E-6, '');

otg.AtTime(otg.Duration, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
values[0] := otg.TargetPosition[0];
values[1] := -1.6825197896;
values[2] := -1.0079368399;
AssertArrayEquals_LREAL(values, NewPosition, 1E-6, '');


// Make sure that disabled DoFs overwrite prior blocks
otg.Enabled[0] := TRUE;
otg.Enabled[1] := TRUE;
otg.Enabled[2] := TRUE;

otg.CurrentPosition[0] := 0;
otg.CurrentPosition[1] := 0;
otg.CurrentPosition[2] := 0;

otg.TargetPosition[0] := 100;
otg.TargetPosition[1] := -3000.0;
otg.TargetPosition[2] := 2000.0;

otg.TargetVelocity[0] := 1;
otg.TargetVelocity[1] := 1;
otg.TargetVelocity[2] := 1;

otg(EnableAutoPropagate := FALSE);
result := otg.State;

otg.Enabled[0] := FALSE;
otg.Enabled[1] := FALSE;
otg.Enabled[2] := TRUE;

otg.CurrentPosition[0] := 0;
otg.CurrentPosition[1] := -2;
otg.CurrentPosition[2] := 0;

otg.CurrentVelocity[0] := 0;
otg.CurrentVelocity[1] := 0.2;
otg.CurrentVelocity[2] := 0;

otg.CurrentAcceleration[0] := 0;
otg.CurrentAcceleration[1] := 0.2;
otg.CurrentAcceleration[2] := 0;

otg.TargetPosition[0] := 1.0;
otg.TargetPosition[1] := -3.0;
otg.TargetPosition[2] := 2.0;

otg.TargetVelocity[0] := 0.0;
otg.TargetVelocity[1] := 0.0;
otg.TargetVelocity[2] := 0.2;

otg.TargetAcceleration[0] := 0.0;
otg.TargetAcceleration[1] := 0.0;
otg.TargetAcceleration[2] := -0.1;

otg.MaxVelocity[0] := 1;
otg.MaxVelocity[1] := 1;
otg.MaxVelocity[2] := 1;

otg.MaxAcceleration[0] := 1;
otg.MaxAcceleration[1] := 1;
otg.MaxAcceleration[2] := 1;

otg.MaxJerk[0] := 1;
otg.MaxJerk[1] := 1;
otg.MaxJerk[2] := 1;

otg(EnableAutoPropagate := FALSE);
result := otg.State;
AssertEquals_LREAL(otg.Duration, 3.6578610221, 1E-6, Message := ''); 

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_FirstStateAtTime" Id="{45288964-70c7-4f04-951a-1ad9938f231b}">
      <Declaration><![CDATA[METHOD Test_FirstStateAtTime
VAR_INST
  otg : Struckig.Otg(0.005, 3) := (
  
    Synchronization := SynchronizationType.TimeSync,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );
    
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('FirstStateAtTime');

otg();

AssertTrue( otg._profiles[0].firstStateAtPosition(0.0, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(0.0, rtime, 1E-9, message:='');

AssertTrue( otg._profiles[0].firstStateAtPosition(0.5, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(2.0, rtime, 1E-9, message:='');

AssertTrue( otg._profiles[0].firstStateAtPosition(1.0, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(3.9999857615998957, rtime, 1E-9, message:=''); // doctest::Approx(4.0) 

AssertTrue( otg._profiles[1].firstStateAtPosition(-3.0, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(2.6004877902, rtime, 1E-9, message:='');

AssertTrue( otg._profiles[1].firstStateAtPosition(-3.1, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(2.8644154489, rtime, 1E-9, message:='');

AssertTrue( otg._profiles[2].firstStateAtPosition(0.05, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(0.6694329501, rtime, 1E-9, message:='');

AssertFalse( otg._profiles[0].firstStateAtPosition(-1.0, 0.0, rtime, rvel, racc), message:='' );
AssertFalse( otg._profiles[1].firstStateAtPosition(-3.4, 0.0, rtime, rvel, racc), message:='' );

// todo: this test doesn't make sense in the port of ruckig, the method is not exposed in the trajectory class yet
// AssertFalse( ruckig._profiles[6].firstStateAtPosition(6, 0.0, rtime, rvel, racc), message:='' );

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_IndependentMinDurations" Id="{a2e696c4-c9ef-4360-ab1b-ce079b7c502e}">
      <Declaration><![CDATA[METHOD Test_IndependentMinDurations
VAR_INST
  otg : Struckig.Otg(0.005, 3) := (
  
    Synchronization := SynchronizationType.None,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );
    
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('IndependentMinDurations');

otg();

AssertEquals_LREAL(otg._independentMinDurations[0], 3.1748021039, 1E-9, message:='');
AssertEquals_LREAL(otg._independentMinDurations[1], 3.6860977315, 1E-9, message:='');
AssertEquals_LREAL(otg._independentMinDurations[2], otg.Duration, 1E-9, message:='');

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_IndependentMinDurations_1" Id="{dc38f254-379a-4b6c-a931-0a161d977592}">
      <Declaration><![CDATA[METHOD Test_IndependentMinDurations_1
VAR_INST
  otg : Struckig.Otg(0.005, 3) := (
    Synchronization := SynchronizationType.None,
    CurrentPosition :=     [ 1300.0, 0.0, 0.02 ],
    CurrentVelocity :=     [ 1200.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1400.0, 0.0, 0.02 ],
    TargetVelocity :=      [ 0.0, 0.0, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 800.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 40000.0, 1.0, 1.0 ],
    MaxJerk :=             [ 200000.0, 1.0, 1.0 ]
  );
    
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('IndependentMinDurations_1');

otg();
AssertEquals_LREAL(otg.Duration, 0.167347, 1E-6, message:='');

AssertEquals_LREAL(otg._independentMinDurations[0], otg.Duration, 1E-9, message:='');
AssertEquals_LREAL(otg._independentMinDurations[1], 0, 1E-9, message:='');
AssertEquals_LREAL(otg._independentMinDurations[2], 0, 1E-9, message:='');

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_InputInitalized" Id="{b3d7b5dd-ee27-45b7-b9cf-deb942269708}">
      <Declaration><![CDATA[METHOD Test_InputInitalized
VAR_INST
  otg : Struckig.Otg(0.005, 2) := (
    MaxVelocity :=         [ 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0 ]
  );
END_VAR
VAR
  nan : LREAL := SQRT(-1);
  result : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('InputInitialized');

AssertFalse(otg._inputInitialized, 'Input is initially not initalized');

otg();

AssertTrue(otg._inputInitialized, 'Input is initialized after the first call to OTG');


TEST_FINISHED();







]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_InputValidation" Id="{ebd76db9-5662-45c4-b273-d537ff4a7faf}">
      <Declaration><![CDATA[METHOD Test_InputValidation
VAR_INST
  otg : Struckig.Otg(0.005, 2) := (
    CurrentPosition :=     [ 0.0, -2.0 ],
    CurrentVelocity :=     [ 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0 ],
    TargetVelocity :=      [ 0.0, 0.3 ],
    TargetAcceleration :=  [ 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0 ]
  );
END_VAR
VAR
  nan : LREAL := SQRT(-1);
  result : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('InputValidation');

result := otg.ValidateInput(checkCurrentStateWithinLimits:=FALSE, checkTargetStateWithinLimits:=TRUE);
AssertTrue(result, '');

otg.MaxJerk[1] := nan;
result := otg.ValidateInput(checkCurrentStateWithinLimits:=FALSE, checkTargetStateWithinLimits:=TRUE);
AssertFalse(result, '');

otg.MaxJerk[1] := 1.0;
otg.CurrentPosition[1] := nan;
result := otg.ValidateInput(checkCurrentStateWithinLimits:=FALSE, checkTargetStateWithinLimits:=TRUE);
AssertFalse(result, '');

otg.CurrentPosition[1] := 1.0;
otg.MaxAcceleration[1] := -1.0;
result := otg.ValidateInput(checkCurrentStateWithinLimits:=FALSE, checkTargetStateWithinLimits:=TRUE);
AssertFalse(result, '');

otg.MaxAcceleration[1] := 1.0;
otg.TargetVelocity[1] := 1.3;
result := otg.ValidateInput(checkCurrentStateWithinLimits:=FALSE, checkTargetStateWithinLimits:=FALSE);
AssertTrue(result, '');
result := otg.ValidateInput(checkCurrentStateWithinLimits:=FALSE, checkTargetStateWithinLimits:=TRUE);
AssertFalse(result, '');

otg.TargetVelocity[1] := 0.3;
otg.CurrentVelocity[0] := 2.0;
result := otg.ValidateInput(checkCurrentStateWithinLimits:=FALSE, checkTargetStateWithinLimits:=FALSE);
AssertTrue(result, '');
result := otg.ValidateInput(checkCurrentStateWithinLimits:=TRUE, checkTargetStateWithinLimits:=FALSE);
AssertFalse(result, '');
result := otg.ValidateInput(checkCurrentStateWithinLimits:=TRUE, checkTargetStateWithinLimits:=TRUE);
AssertFalse(result, '');
result := otg.ValidateInput(checkCurrentStateWithinLimits:=FALSE, checkTargetStateWithinLimits:=TRUE);
AssertTrue(result, '');

otg.CurrentVelocity[0] := 1.0;
otg.CurrentAcceleration[0] := -1.0;
result := otg.ValidateInput(checkCurrentStateWithinLimits:=FALSE, checkTargetStateWithinLimits:=TRUE);
AssertTrue(result, '');
result := otg.ValidateInput(checkCurrentStateWithinLimits:=TRUE, checkTargetStateWithinLimits:=TRUE);
AssertTrue(result, '');

otg.CurrentVelocity[0] := 1.0;
otg.CurrentAcceleration[0] := 1.0;
result := otg.ValidateInput(checkCurrentStateWithinLimits:=FALSE, checkTargetStateWithinLimits:=TRUE);
AssertTrue(result, '');
result := otg.ValidateInput(checkCurrentStateWithinLimits:=TRUE, checkTargetStateWithinLimits:=TRUE);
AssertFalse(result, '');

otg.CurrentVelocity[0] := 0.72;
otg.CurrentAcceleration[0] := 0.72;
result := otg.ValidateInput(checkCurrentStateWithinLimits:=TRUE, checkTargetStateWithinLimits:=TRUE);
AssertTrue(result, '');

otg.CurrentVelocity[0] := 0;
otg.CurrentVelocity[1] := 0;
otg.CurrentAcceleration[0] := 0;
otg.CurrentAcceleration[1] := 0;
otg.TargetVelocity[0] := 0;
otg.TargetVelocity[1] := 0.72;
otg.TargetAcceleration[0] := 0;
otg.TargetAcceleration[1] := 0.72;
result := otg.ValidateInput(checkCurrentStateWithinLimits:=FALSE, checkTargetStateWithinLimits:=TRUE);
AssertTrue(result, '');

otg.TargetVelocity[1] := 1.0;
otg.TargetAcceleration[1] := 1.0;
result := otg.ValidateInput(checkCurrentStateWithinLimits:=FALSE, checkTargetStateWithinLimits:=TRUE);
AssertTrue(result, '');

otg.TargetVelocity[1] := 1.0;
otg.TargetAcceleration[1] := -0.0001;
result := otg.ValidateInput(checkCurrentStateWithinLimits:=FALSE, checkTargetStateWithinLimits:=TRUE);
AssertFalse(result, '');

TEST_FINISHED();







]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_InvalidInput" Id="{7f2842b5-4b27-40e5-9e8d-50abf85326e8}">
      <Declaration><![CDATA[METHOD Test_InvalidInput
VAR_INST
  otg : Struckig.Otg(0.005, 3) := (
  
    Synchronization := SynchronizationType.None,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );
    
END_VAR
VAR
  nan : LREAL := SQRT(-1);  
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('InvalidInput');

otg();

otg.TargetVelocity[0] := 2.0;
otg.TargetVelocity[1] := 0.3;
otg.TargetVelocity[2] := 0.0;

otg();

AssertEquals_INT(Struckig.TrajectoryState.Error, otg.State, message:='State should be error');
AssertEquals_INT(Struckig.TrajectoryErrorCode.InvalidInput, otg.ErrorCode(), message:='Invalid input error');
AssertEquals_STRING('target velocity exceeds its maximum velocity limit', otg.ErrorMessage(), message:='');

AssertFalse(otg.NewCalculation, message:='ruckig.NewCalculation should be false');

otg.TargetVelocity[0] := 0.2;
otg.TargetVelocity[1] := -0.3;
otg.TargetVelocity[2] := 0.8;

otg();

AssertEquals_INT(Struckig.TrajectoryState.Busy, otg.State, message:='State should be busy');
AssertTrue(otg.NewCalculation, message:='ruckig.NewCalculation should be true');


otg.MaxJerk[0] := 1.0;
otg.MaxJerk[1] := nan;

otg();

AssertEquals_INT(Struckig.TrajectoryState.Error, otg.State, message:='State should be error');
AssertEquals_INT(Struckig.TrajectoryErrorCode.InvalidInput, otg.ErrorCode(), message:='Invalid input error');
AssertEquals_STRING('maximum jerk limit should be larger than or equal to zero', otg.ErrorMessage(), message:='');


otg.MaxJerk[0] := 1.0;
otg.MaxJerk[1] := 1.0;
otg.CurrentPosition[0] := 1.0;
otg.CurrentPosition[1] := nan;

otg();

AssertEquals_INT(Struckig.TrajectoryState.Error, otg.State, message:='State should be error');
AssertEquals_INT(Struckig.TrajectoryErrorCode.InvalidInput, otg.ErrorCode(), message:='Invalid input error');
AssertEquals_STRING('current position should be a valid number', otg.ErrorMessage(), message:='');

otg.CurrentPosition[0] := 1.0;
otg.CurrentPosition[1] := 1.0;
otg.MaxAcceleration[0] := 1.0;
otg.MaxAcceleration[1] := -11.0;

otg();

AssertEquals_INT(Struckig.TrajectoryState.Error, otg.State, message:='State should be error');
AssertEquals_INT(Struckig.TrajectoryErrorCode.InvalidInput, otg.ErrorCode(), message:='Invalid input error');
AssertEquals_STRING('maximum acceleration limit should be larger than or equal to zero', otg.ErrorMessage(), message:='');



otg.MaxAcceleration[0] := 1.0;
otg.MaxAcceleration[1] := 1.0;
otg.MaxVelocity[0] := 1.0;
otg.MaxVelocity[1] := -1.0;

otg();

AssertEquals_INT(Struckig.TrajectoryState.Error, otg.State, message:='State should be error');
AssertEquals_INT(Struckig.TrajectoryErrorCode.InvalidInput, otg.ErrorCode(), message:='Invalid input error');
AssertEquals_STRING('maximum velocity limit should be larger than or equal to zero', otg.ErrorMessage(), message:='');


otg.MaxVelocity[0] := 1.0;
otg.MaxVelocity[1] := 1.0;
otg.TargetVelocity[0] := 0;
otg.TargetVelocity[0] := 1.3;

otg();

AssertEquals_INT(Struckig.TrajectoryState.Error, otg.State, message:='State should be error');
AssertEquals_INT(Struckig.TrajectoryErrorCode.InvalidInput, otg.ErrorCode(), message:='Invalid input error');
AssertEquals_STRING('target velocity exceeds its maximum velocity limit', otg.ErrorMessage(), message:='');


TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_PerDofSettings" Id="{f04c0bef-a3eb-4d96-bb99-65b90fd47937}">
      <Declaration><![CDATA[METHOD Test_PerDofSettings
VAR_INST
  otg : Struckig.Otg(0.005, 3) := (
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );
    
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  NewSection : INT;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('PerDofSettings');

otg();
AssertEquals_INT(otg.State, Struckig.TrajectoryState.Busy, message:='State should be busy');
AssertEquals_LREAL(otg.Duration, 4, 1E-6, message:='Duration not met');

otg.AtTime(2.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
values[0] := 0.5;
values[1] := -2.6871268303;
values[2] :=  1.0;
AssertArrayEquals_LREAL(values, NewPosition, 1E-6, message:='Position not met');


otg.ControlInterface := ControlInterfaceType.Velocity;
otg();
AssertEquals_INT(otg.State, Struckig.TrajectoryState.Busy, message:='State should be busy');
AssertEquals_LREAL(otg.Duration, 1.095445115, 1E-6, message:='Duration not met');

otg.AtTime(1.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
values[0] := 0.0;
values[1] := -1.8641718534;
values[2] :=  0.0;
AssertArrayEquals_LREAL(values, NewPosition, 1E-6, message:='Position not met');


otg.PerDofControlInterface[0] := ControlInterfaceType.Position;
otg.PerDofControlInterface[1] := ControlInterfaceType.Velocity;
otg.PerDofControlInterface[2] := ControlInterfaceType.Position;
otg();
AssertEquals_INT(otg.State, Struckig.TrajectoryState.Busy, message:='State should be busy');
AssertEquals_LREAL(otg.Duration, 4.0, 1E-6, message:='Duration not met');

otg.AtTime(2.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
values[0] := 0.5;
values[1] := -1.8528486838;
values[2] := 1.0;
AssertArrayEquals_LREAL(values, NewPosition, 1E-6, message:='Position not met');


otg.PerDofSynchronization[0] := SynchronizationType.TimeSync;
otg.PerDofSynchronization[1] := SynchronizationType.None;
otg.PerDofSynchronization[2] := SynchronizationType.TimeSync;
otg();
AssertEquals_INT(otg.State, Struckig.TrajectoryState.Busy, message:='State should be busy');
AssertEquals_LREAL(otg.Duration, 4.0, 1E-6, message:='Duration not met');

otg.AtTime(2.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
values[0] := 0.5;
values[1] := -1.5643167673;
values[2] := 1.0;
AssertArrayEquals_LREAL(values, NewPosition, 1E-6, message:='Position not met');

otg.ControlInterface := ControlInterfaceType.Position;
otg.PerDofControlInterface[0] := ControlInterfaceType.Undefined;
otg.PerDofControlInterface[1] := ControlInterfaceType.Undefined;
otg.PerDofControlInterface[2] := ControlInterfaceType.Undefined;
otg.PerDofSynchronization[0] := SynchronizationType.None;
otg.PerDofSynchronization[1] := SynchronizationType.TimeSync;
otg.PerDofSynchronization[2] := SynchronizationType.TimeSync;
otg();
AssertEquals_INT(otg.State, Struckig.TrajectoryState.Busy, message:='State should be busy');
AssertEquals_LREAL(otg.Duration, 4.0, 1E-6, message:='Duration not met');

otg.AtTime(2.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
values[0] := 0.7482143874;
values[1] := -2.6871268303;
values[2] := 1.0;
AssertArrayEquals_LREAL(values, NewPosition, 1E-6, message:='Position not met');

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_PerDofSettings_1" Id="{2ccfa256-25fb-418a-a177-0090195ed66b}">
      <Declaration><![CDATA[METHOD Test_PerDofSettings_1
VAR_INST
  otg : Struckig.Otg(0.005, 3) := (
    CurrentPosition :=     [ 0.0, 0.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 35, 35, 35 ],
    TargetVelocity :=      [ 125, 125, 100 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 125, 125, 100 ],
    MaxAcceleration :=     [ 2000, 2000, 2000 ],
    MaxJerk :=             [ 20000, 20000, 20000 ]
  );
    
END_VAR
VAR
  result : Struckig.TrajectoryState;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('PerDofSettings_1');

otg.ControlInterface := ControlInterfaceType.Position;
otg.PerDofControlInterface[0] := ControlInterfaceType.Undefined;
otg.PerDofControlInterface[1] := ControlInterfaceType.Undefined;
otg.PerDofControlInterface[2] := ControlInterfaceType.Undefined;
otg.PerDofSynchronization[0] := SynchronizationType.TimeSync;
otg.PerDofSynchronization[1] := SynchronizationType.TimeSync;
otg.PerDofSynchronization[2] := SynchronizationType.None;
otg();
AssertEquals_INT(otg.State, Struckig.TrajectoryState.Busy, message:='State should be busy');
AssertEquals_LREAL(otg.Duration, 0.4207106781, 1E-6, message:='Duration not met');


otg.CurrentPosition[0] := 0;
otg.CurrentPosition[1] := -2;
otg.CurrentPosition[2] := 0;

otg.CurrentVelocity[0] := 0;
otg.CurrentVelocity[1] := 0.2;
otg.CurrentVelocity[2] := 0;

otg.CurrentAcceleration[0] := 0;
otg.CurrentAcceleration[1] := 0.2;
otg.CurrentAcceleration[2] := 0;

otg.TargetPosition[0] := 1.0;
otg.TargetPosition[1] := -3.0;
otg.TargetPosition[2] := 2.0;

otg.TargetVelocity[0] := 0.0;
otg.TargetVelocity[1] := 0.0;
otg.TargetVelocity[2] := 0.2;

otg.TargetAcceleration[0] := 0.0;
otg.TargetAcceleration[1] := 0.0;
otg.TargetAcceleration[2] := -0.1;

otg.MaxVelocity[0] := 1;
otg.MaxVelocity[1] := 1;
otg.MaxVelocity[2] := 1;

otg.MaxAcceleration[0] := 1;
otg.MaxAcceleration[1] := 1;
otg.MaxAcceleration[2] := 1;

otg.MaxJerk[0] := 1;
otg.MaxJerk[1] := 1;
otg.MaxJerk[2] := 1;

otg.PerDofSynchronization[0] := SynchronizationType.None;
otg.PerDofSynchronization[1] := SynchronizationType.None;
otg.PerDofSynchronization[2] := SynchronizationType.TimeSync;

otg();
AssertEquals_INT(otg.State, Struckig.TrajectoryState.Busy, message:='State should be busy');
AssertEquals_LREAL(otg.Duration, 3.7885667284, 1E-6, message:='Duration not met');

otg.PerDofSynchronization[0] := SynchronizationType.None;
otg.PerDofSynchronization[1] := SynchronizationType.TimeSync;
otg.PerDofSynchronization[2] := SynchronizationType.None;

otg();
AssertEquals_INT(otg.State, Struckig.TrajectoryState.Busy, message:='State should be busy');
AssertEquals_LREAL(otg.Duration, 3.7885667284, 1E-6, message:='Duration not met');

otg.Enabled[0] := TRUE;
otg.Enabled[1] := FALSE;
otg.Enabled[2] := TRUE;

otg();
AssertEquals_INT(otg.State, Struckig.TrajectoryState.Busy, message:='State should be busy');
AssertEquals_LREAL(otg.Duration, 3.6578610221, 1E-6, message:='Duration not met');



SetVector3(ADR(otg.CurrentPosition),0,0,0);
SetVector3(ADR(otg.CurrentVelocity),0.2,0,-0.1);
SetVector3(ADR(otg.CurrentAcceleration),0,0,0);
SetVector3(ADR(otg.TargetPosition),1,-0.2,-0.5);
SetVector3(ADR(otg.TargetVelocity),0,0,0);
SetVector3(ADR(otg.TargetAcceleration),0,0,0);
SetVector3(ADR(otg.MaxVelocity),1,1,1);
SetVector3(ADR(otg.MaxAcceleration),1,1,1);
SetVector3(ADR(otg.MaxJerk),1,1,1);
otg.Enabled[0] := TRUE;
otg.Enabled[1] := TRUE;
otg.Enabled[2] := TRUE;
otg.PerDofSynchronization[0] := Struckig.SynchronizationType.Phase;
otg.PerDofSynchronization[1] := Struckig.SynchronizationType.None;
otg.PerDofSynchronization[2] := Struckig.SynchronizationType.Phase;
otg();
AssertEquals_INT(TrajectoryState.Busy, otg.State, '');
AssertEquals_LREAL(otg.Duration, 2.848387279, 1E-6, Message := '');
AssertTrue(ABS(otg._profiles[0].t[0] - otg._profiles[1].t[0]) > 1E-6, Message := '');  // Todo: AssertArrayNotEquals_LREAL 
AssertArrayEquals_LREAL( otg._profiles[0].t, otg._profiles[2].t, 1E-6, Message := '');



TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_PhaseSynchronization" Id="{df39aa3d-ca70-4d91-9685-7c579cd985d7}">
      <Declaration><![CDATA[METHOD Test_PhaseSynchronization
VAR_INST
  otg : Struckig.Otg(0.005, 3) := (
    Synchronization := SynchronizationType.Phase,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ],
    EnableAutoPropagate := FALSE
  ); 
END_VAR
VAR
  result : Struckig.TrajectoryState;
  busy : Struckig.TrajectoryState := Struckig.TrajectoryState.Busy;
  NewSection : INT;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
  profiles : POINTER TO ProfileDesc := ADR(otg._profiles);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('PhaseSynchronization');

otg();
result := otg.State;
AssertEquals(busy, result, Message := '');
AssertEquals_LREAL(otg.Duration, 4.0, 1E-6, Message := ''); 
AssertArrayEquals_LREAL( profiles[0].t, profiles[1].t, 1E-6, Message := ''); 
AssertArrayEquals_LREAL( profiles[0].t, profiles[2].t, 1E-6, Message := ''); 

otg.AtTime(1.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
SetVector3(ADR(values), 0.0833333333, -2.0833333333, 0.1666666667);
AssertArrayEquals_LREAL(values, NewPosition, 1E-6, '');
AssertArrayEquals_LREAL( profiles[0].t, profiles[1].t, 1E-6, Message := ''); 
AssertArrayEquals_LREAL( profiles[0].t, profiles[2].t, 1E-6, Message := ''); 




SetVector3(ADR(otg.CurrentPosition),0,-2,0);
SetVector3(ADR(otg.TargetPosition),10,-3,2);
SetVector3(ADR(otg.MaxVelocity),10,2,1);
SetVector3(ADR(otg.MaxAcceleration),10,2,1);
SetVector3(ADR(otg.MaxJerk),10,2,1);
otg();
result := otg.State;
AssertEquals(busy, result, Message := '');
AssertEquals_LREAL(otg.Duration, 4.0, 1E-6, Message := ''); 
otg.AtTime(1.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
SetVector3(ADR(values), 0.833333333, -2.0833333333, 0.1666666667);
AssertArrayEquals_LREAL(values, NewPosition, 1E-6, '');
AssertArrayEquals_LREAL( profiles[0].t, profiles[1].t, 1E-6, Message := ''); 
AssertArrayEquals_LREAL( profiles[0].t, profiles[2].t, 1E-6, Message := ''); 


// Test equal start and target state
SetVector3(ADR(otg.CurrentPosition), 1,-2,3);
SetVector3(ADR(otg.TargetPosition), 1,-2,3);
otg();
otg.AtTime(0.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
AssertEquals_LREAL(otg.Duration, 0.0, 1E-6, Message := '');
AssertEquals_INT(TrajectoryState.Idle, otg.State, '');
SetVector3(ADR(values), 1, -2, 3);
AssertArrayEquals_LREAL(values, NewPosition, 1E-6, '');
AssertArrayEquals_LREAL( profiles[0].t, profiles[1].t, 1E-6, Message := ''); 
AssertArrayEquals_LREAL( profiles[0].t, profiles[2].t, 1E-6, Message := ''); 



SetVector3(ADR(otg.CurrentPosition),0,0,0);
SetVector3(ADR(otg.CurrentVelocity),0,0,0);
SetVector3(ADR(otg.CurrentAcceleration),0,0,0);
SetVector3(ADR(otg.TargetPosition),0,0,0);
SetVector3(ADR(otg.TargetVelocity),0.2,0.3,0.4);
SetVector3(ADR(otg.TargetAcceleration),0,0,0);
SetVector3(ADR(otg.MaxVelocity),1,1,1);
SetVector3(ADR(otg.MaxAcceleration),1,1,1);
SetVector3(ADR(otg.MaxJerk),1,1,1);
otg();
AssertEquals_INT(TrajectoryState.Busy, otg.State, '');
AssertArrayEquals_LREAL( profiles[0].t, profiles[1].t, 1E-6, Message := '');   
AssertArrayEquals_LREAL( profiles[0].t, profiles[2].t, 1E-6, Message := '');   





SetVector3(ADR(otg.CurrentPosition),0,0,0);
SetVector3(ADR(otg.CurrentVelocity),0,0,0);
SetVector3(ADR(otg.CurrentAcceleration),0,0,0);
SetVector3(ADR(otg.TargetPosition),0,0,0.01);
SetVector3(ADR(otg.TargetVelocity),0.2,0.3,0.4);
SetVector3(ADR(otg.TargetAcceleration),0,0,0);
otg();
AssertEquals_INT(TrajectoryState.Busy, otg.State, '');
AssertTrue(ABS(profiles[0].t[0] - profiles[1].t[0]) > 1E-6, Message := '');  // Todo: AssertArrayNotEquals_LREAL
AssertTrue(ABS(profiles[0].t[0] - profiles[2].t[0]) > 1E-6, Message := '');  // Todo: AssertArrayNotEquals_LREAL





SetVector3(ADR(otg.CurrentPosition), 0,0,0);
SetVector3(ADR(otg.CurrentVelocity), 0.4, 0.15, 0.2);
SetVector3(ADR(otg.CurrentAcceleration), 0.8,0.3,0.4);
SetVector3(ADR(otg.TargetPosition), 0,0,0);
SetVector3(ADR(otg.TargetVelocity), 0,0,0);
SetVector3(ADR(otg.TargetAcceleration), 0,0,0);
otg();
AssertEquals_INT(TrajectoryState.Busy, otg.State, '');
AssertArrayEquals_LREAL( profiles[0].t, profiles[1].t, 1E-6, Message := '');
AssertArrayEquals_LREAL( profiles[0].t, profiles[2].t, 1E-6, Message := ''); 



SetVector3(ADR(otg.MaxVelocity), 1,0.2,1);
otg();
AssertEquals_INT(TrajectoryState.Busy, otg.State, '');
AssertTrue(ABS(profiles[0].t[0] - profiles[1].t[0]) > 1E-6, Message := '');  // Todo: AssertArrayNotEquals_LREAL
AssertTrue(ABS(profiles[0].t[0] - profiles[2].t[0]) > 1E-6, Message := '');  // Todo: AssertArrayNotEquals_LREAL







SetVector3(ADR(otg.CurrentPosition),0,0.02,1);
SetVector3(ADR(otg.CurrentVelocity),-0.2,0.15,0.2);
SetVector3(ADR(otg.CurrentAcceleration),-0.4,0.3,0.4);
SetVector3(ADR(otg.TargetPosition),0.03,0,0);
SetVector3(ADR(otg.TargetVelocity),-0.02,0.015,0.02);
SetVector3(ADR(otg.TargetAcceleration),0,0,0);
SetVector3(ADR(otg.MaxVelocity),1,1,1);
SetVector3(ADR(otg.MaxAcceleration),1,1,1);
SetVector3(ADR(otg.MaxJerk),1,1,1);
otg.ControlInterface := ControlInterfaceType.Velocity;
otg();
AssertEquals_INT(TrajectoryState.Busy, otg.State, '');
AssertArrayEquals_LREAL( profiles[0].t, profiles[1].t, 1E-6, Message := '');
AssertArrayEquals_LREAL( profiles[0].t, profiles[2].t, 1E-6, Message := ''); 




SetVector3(ADR(otg.MaxJerk),1,0.1,1);
otg();
AssertEquals_INT(TrajectoryState.Busy, otg.State, '');
AssertArrayEquals_LREAL( profiles[0].t, profiles[1].t, 1E-6, Message := '');
AssertArrayEquals_LREAL( profiles[0].t, profiles[2].t, 1E-6, Message := ''); 




SetVector3(ADR(otg.TargetAcceleration),0.01,0,0);
otg();
AssertEquals_INT(TrajectoryState.Busy, otg.State, '');
AssertTrue(ABS(profiles[0].t[2] - profiles[1].t[2]) > 1E-6, Message := '');  // Todo: AssertArrayNotEquals_LREAL
AssertTrue(ABS(profiles[0].t[2] - profiles[2].t[2]) > 1E-6, Message := '');  // Todo: AssertArrayNotEquals_LREAL




SetVector3(ADR(otg.CurrentPosition),0,0,0);
SetVector3(ADR(otg.CurrentVelocity),0,0,0);
SetVector3(ADR(otg.CurrentAcceleration),0,0,0);
SetVector3(ADR(otg.TargetPosition),0,0,0);
SetVector3(ADR(otg.TargetVelocity),0,0,0);
SetVector3(ADR(otg.TargetAcceleration),0,0,0);
otg();
AssertEquals_INT(TrajectoryState.Idle, otg.State, '');


TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_PositionExtrema" Id="{59aa613e-c11d-40bf-a12f-16c3c93702fe}">
      <Declaration><![CDATA[METHOD Test_PositionExtrema
VAR_INST
  otg : Struckig.Otg(0.005, 3) := (
    Synchronization := SynchronizationType.TimeSync,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );     
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('PositionExtrema');

otg();

positionExtrema := otg._profiles[0].positionExtrema();
AssertEquals_LREAL(4.0, positionExtrema.Tmax, 1E-9, message:='Profile[0] Tmax incorrect');
AssertEquals_LREAL(1.0, positionExtrema.Maximum, 1E-9, message:='Profile[0] maximum incorrect');
AssertEquals_LREAL(0.0, positionExtrema.Tmin, 1E-9, message:='Profile[0] Tmin incorrect');
AssertEquals_LREAL(0.0, positionExtrema.Minimum, 1E-9, message:='Profile[0] minimum incorrect');

positionExtrema := otg._profiles[1].positionExtrema();
AssertEquals_LREAL(0.0, positionExtrema.Tmax, 1E-9, message:='Profile[1] Tmax incorrect');
AssertEquals_LREAL(-2.0, positionExtrema.Maximum, 1E-9, message:='Profile[1] maximum incorrect');
AssertEquals_LREAL(3.2254033308, positionExtrema.Tmin, 1E-9, message:='Profile[1] Tmin incorrect');
AssertEquals_LREAL(-3.1549193338, positionExtrema.Minimum, 1E-9, message:='Profile[1] minimum incorrect');

positionExtrema := otg._profiles[2].positionExtrema();
AssertEquals_LREAL(4.0, positionExtrema.Tmax, 1E-9, message:='Profile[2] Tmax incorrect');
AssertEquals_LREAL(2.0, positionExtrema.Maximum, 1E-9, message:='Profile[2] maximum incorrect');
AssertEquals_LREAL(0.0, positionExtrema.Tmin, 1E-9, message:='Profile[2] Tmin incorrect');
AssertEquals_LREAL(0.0, positionExtrema.Minimum, 1E-9, message:='Profile[2] minimum incorrect');

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>