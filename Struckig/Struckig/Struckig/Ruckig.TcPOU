<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="Ruckig" Id="{1c5850a2-5b12-4229-9d95-591ad970a07b}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK Ruckig
VAR
  _currentInput : InputParameter(0);
  _dt : LREAL; // Time step between updates (cycle time) in [s]
  _state : TrajectoryState;
  _errorId : INT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="Calculate" Id="{d4e77b2d-b7a2-4486-8e6b-9e101a6d8b8b}">
      <Declaration><![CDATA[METHOD PRIVATE Calculate : TrajectoryErrorCode
VAR_INPUT
  input : REFERENCE TO InputParameter;
  output : REFERENCE TO OutputParameter;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_state := TrajectoryState.Busy;

IF NOT ValidateInput(input)
THEN
  Calculate := TrajectoryErrorCode.InvalidInput;
  RETURN;
END_IF

Calculate := output.Trajectory.Calculate(input, _dt);
IF (Calculate <> 0) THEN
  RETURN;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{b602f7a7-4307-4d87-b5fe-4e3716d1e55b}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
  deltaTime : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_dt := deltaTime;]]></ST>
      </Implementation>
    </Method>
    <Method Name="HasChanged" Id="{412a3b6e-c01a-46d6-b769-48dae1ba53ec}">
      <Declaration><![CDATA[METHOD PRIVATE HasChanged : BOOL
VAR_INPUT
  lhs : REFERENCE TO InputParameter;
  rhs : REFERENCE TO InputParameter;  
END_VAR
VAR
  i : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF lhs._dofs <> rhs._dofs
THEN
  HasChanged := TRUE;
  RETURN;
END_IF

FOR i:=0 TO lhs._dofs-1
DO
  IF lhs.CurrentPosition[i] <> rhs.CurrentPosition[i] OR_ELSE
     lhs.CurrentVelocity[i] <> rhs.CurrentVelocity[i] OR_ELSE
     lhs.CurrentAcceleration[i] <> rhs.CurrentAcceleration[i] OR_ELSE
     lhs.TargetPosition[i] <> rhs.TargetPosition[i] OR_ELSE
     lhs.TargetVelocity[i] <> rhs.TargetVelocity[i] OR_ELSE
     lhs.TargetAcceleration[i] <> rhs.TargetAcceleration[i] OR_ELSE
     lhs.MaxVelocity[i] <> rhs.MaxVelocity[i] OR_ELSE
     lhs.MaxAcceleration[i] <> rhs.MaxAcceleration[i] OR_ELSE
     lhs.MaxJerk[i] <> rhs.MaxJerk[i] OR_ELSE
     lhs._enabled[i] <> rhs._enabled[i] OR_ELSE
     lhs.MinVelocity[i] <> rhs.MinVelocity[i] OR_ELSE
     lhs.MinAcceleration[i] <> rhs.MinAcceleration[i]
  THEN
    HasChanged := TRUE;  
    RETURN;
	END_IF
END_FOR

IF lhs.ControlInterface <> rhs.ControlInterface OR_ELSE
   lhs.Synchronization <> rhs.Synchronization OR_ELSE
   lhs.Discretization <> rhs.Discretization OR_ELSE
   lhs.MinDuration <> rhs.MinDuration   
THEN
  HasChanged := TRUE;
  RETURN;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Update" Id="{6c3982fb-7e79-4dd7-bf3c-9a685156d3bb}">
      <Declaration><![CDATA[METHOD Update : TrajectoryState;
VAR_INPUT
  input : REFERENCE TO InputParameter;
  output : REFERENCE TO  OutputParameter;  
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[output.NewCalculation := FALSE;

IF HasChanged(input, _currentInput)
THEN
  _state := TrajectoryState.Busy;
  _errorId := Calculate(input, output);
  IF _errorId <> 0 THEN
    Update := _state := TrajectoryState.Error;
    RETURN;
  END_IF
  
  Update := _state;  
  _currentInput := input;
  output.CurrentTime := 0.0;
  output.NewCalculation := TRUE;  
END_IF

output.CurrentTime := output.CurrentTime + _dt;
output.Trajectory.AtTime(output.CurrentTime, input._dofs, ADR(output.NewPosition), ADR(output.NewVelocity), ADR(output.NewAcceleration));

_currentInput.CurrentPosition := output.NewPosition;
_currentInput.CurrentVelocity := output.NewVelocity;
_currentInput.CurrentAcceleration := output.NewAcceleration;

IF (output.CurrentTime > output.Trajectory.Duration) THEN
  _state := TrajectoryState.Idle;
END_IF

Update := _state;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ValidateInput" Id="{e330fefe-c82d-4b3b-9555-b849f32242ef}">
      <Declaration><![CDATA[METHOD ValidateInput : BOOL
VAR_INPUT
  input : REFERENCE TO InputParameter;
END_VAR
VAR
  dof : INT;
  min_velocity, v_diff, max_target_acceleration : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR dof:=0 TO input._dofs-1
DO
  IF (input.ControlInterface = ControlInterfaceType.position AND_THEN input.CurrentPosition[dof] <> input.CurrentPosition[dof]) THEN // isnan
    RETURN;
  END_IF
  
  IF (input.ControlInterface = ControlInterfaceType.position AND_THEN input.MaxVelocity[dof] <> input.MaxVelocity[dof]) THEN // isnan
    RETURN;
  END_IF  

  IF (input.ControlInterface = ControlInterfaceType.position AND_THEN input.MaxVelocity[dof] <= Constants.Minimum) THEN
    RETURN;
  END_IF

  IF (input.MinVelocity[dof] <> 0 AND_THEN input.MinVelocity[dof] >= -Constants.Minimum) THEN
    RETURN;
  END_IF

  IF (input.MaxAcceleration[dof] <> input.MaxAcceleration[dof]) THEN // isnan
    RETURN;
  END_IF
  
  IF (input.MaxAcceleration[dof] <= Constants.Minimum) THEN
    RETURN;
  END_IF

  IF (input.MinAcceleration[dof] <> 0 AND_THEN input.MinAcceleration[dof] >= -Constants.Minimum) THEN
    RETURN;
  END_IF

  IF (input.MaxJerk[dof] <= Constants.Minimum) THEN
    RETURN;
  END_IF

  IF (input.ControlInterface = ControlInterfaceType.position AND_THEN input.TargetPosition[dof] <> input.TargetPosition[dof]) THEN
    RETURN;
  END_IF

  IF (input.ControlInterface = ControlInterfaceType.position) THEN
    IF (input.MinVelocity[dof] <> 0) THEN
      IF (input.TargetVelocity[dof] > input.MaxVelocity[dof] OR_ELSE input.TargetVelocity[dof] < input.MinVelocity[dof]) THEN
          RETURN;
      END_IF
  
    ELSE
      IF (ABS(input.TargetVelocity[dof]) > input.MaxVelocity[dof]) THEN
          RETURN;
      END_IF
    END_IF
  END_IF

  IF (input.MinAcceleration[dof] <> 0) THEN
    IF (input.TargetAcceleration[dof] > input.MaxAcceleration[dof] OR_ELSE input.TargetAcceleration[dof] < input.MinAcceleration[dof]) THEN
        RETURN;
    END_IF

  ELSE
    IF (ABS(input.TargetAcceleration[dof]) > input.MaxAcceleration[dof]) THEN
        RETURN;
    END_IF
  END_IF

  // Target acceleration needs to be accessible from "above" and "below"
  IF (input.ControlInterface = ControlInterfaceType.position) THEN
    min_velocity := SEL(input.MinVelocity[dof] <> 0, -input.MaxVelocity[dof], input.MinVelocity[dof]);
    v_diff := MIN(ABS(input.MaxVelocity[dof] - input.TargetVelocity[dof]), ABS(min_velocity - input.TargetVelocity[dof]));
    max_target_acceleration := SQRT(2 * input.MaxJerk[dof] * v_diff);
    IF (ABS(input.TargetAcceleration[dof]) > max_target_acceleration) THEN
      RETURN;
    END_IF
  END_IF
END_FOR


ValidateInput := TRUE;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>