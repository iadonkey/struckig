<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="VelocityStep1" Id="{0bad3140-2221-4abc-b516-4f31ef4a9048}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK VelocityStep1 
VAR
  p0, v0, a0 : LREAL;
  vf, af : LREAL;
  aMax, aMin, jMax : LREAL;
  
  ValidProfiles : ARRAY[0..2] OF ProfileDesc; // Max 3 valid profiles
  ValidProfileCount : INT := -1;  
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="AddInterval" Id="{abe80916-4a80-43b9-af2c-99fa0b29f681}">
      <Declaration><![CDATA[METHOD AddInterval
VAR_INPUT
  interval : REFERENCE TO BlockInterval;
  Left : REFERENCE TO ProfileDesc;
  Right : REFERENCE TO ProfileDesc;
END_VAR
VAR_INST
  left_duration,right_duration : LREAL;   
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[left_duration := Left.t_sum[6] + Left.t_brake;
right_duration := Right.t_sum[6] + Right.t_brake;
IF (left_duration < right_duration)
THEN
  interval.Left := left_duration;
  interval.Right := right_duration;
  interval.Profile := Right;
ELSE
  interval.Left := right_duration;
  interval.Right := left_duration;
  interval.Profile := Left;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddProfile" Id="{dacf2638-5b01-461d-88f3-34e16bac6e68}">
      <Declaration><![CDATA[METHOD AddProfile
VAR_IN_OUT
  Profile : ProfileDesc;
  jMax : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Profile.pf := Profile.p[7];
Profile.Direction := SEL((jMax > 0), ProfileDirection.Down, ProfileDirection.Up);
ValidProfileCount := ValidProfileCount + 1;
ValidProfiles[ValidProfileCount] := Profile;]]></ST>
      </Implementation>
    </Method>
    <Method Name="CalculateBlock" Id="{dc46def7-4a89-4ab7-8711-fc35caa0cac8}">
      <Declaration><![CDATA[METHOD CalculateBlock : BOOL
VAR_INPUT
  block : REFERENCE TO Block;
END_VAR
VAR
  i, j : INT;
  Tmin : LREAL;
  idx_min : INT;
  idx_else_1, idx_else_2, idx_else_3, idx_else_4 : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (ValidProfileCount = 0) OR_ELSE (ValidProfileCount = 1 AND_THEN ABS(ValidProfiles[0].t_sum[6] - ValidProfiles[1].t_sum[6]) < 8*Constants.Epsilon)
THEN
  block.p_min := ValidProfiles[0];
  block.Tmin := block.p_min.t_sum[6] + block.p_min.t_brake;  
  CalculateBlock := TRUE;
  RETURN;
// Only happens due to numerical issues
ELSIF (ValidProfileCount = 3) 
THEN
  // Find "identical" profiles
  IF (ABS(ValidProfiles[0].t_sum[6] - ValidProfiles[1].t_sum[6]) < 16*Constants.Epsilon OR_ELSE ValidProfiles[0].Direction <> ValidProfiles[1].Direction)
  THEN
    RemoveProfile(1);
  ELSIF (ABS(ValidProfiles[1].t_sum[6] - ValidProfiles[2].t_sum[6]) < 16*Constants.Epsilon  OR_ELSE ValidProfiles[2].Direction <> ValidProfiles[2].Direction)
  THEN
    RemoveProfile(2);
  ELSIF (ABS(ValidProfiles[0].t_sum[6] - ValidProfiles[2].t_sum[6]) < 256*Constants.Epsilon OR_ELSE ValidProfiles[0].Direction <> ValidProfiles[2].Direction)
  THEN
    RemoveProfile(2);
  ELSE
    RETURN;
  END_IF

ELSIF ((ValidProfileCount+1) MOD 2 = 0)
THEN
  RETURN;
END_IF

// Find index of fastest Profilefile
Tmin := Constants.Infinity;
FOR i:=0 TO ValidProfileCount
DO
  FOR j:=0 TO ValidProfileCount
  DO
    IF ValidProfiles[i].t_sum[6] + ValidProfiles[i].t_brake < ValidProfiles[j].t_sum[6] + ValidProfiles[j].t_brake AND_THEN
       ValidProfiles[i].t_sum[6] + ValidProfiles[i].t_brake < Tmin
    THEN
      Tmin := ValidProfiles[i].t_sum[6] + ValidProfiles[i].t_brake;
      idx_min := i;
		END_IF
  END_FOR
END_FOR

block.p_min := ValidProfiles[idx_min];
block.Tmin := block.p_min.t_sum[6] + block.p_min.t_brake;  

IF (ValidProfileCount = 2)
THEN
  idx_else_1 := (idx_min + 1) MOD 3;
  idx_else_2 := (idx_min + 2) MOD 3;
  
  AddInterval(block.a, ValidProfiles[idx_else_1], ValidProfiles[idx_else_2]);
  CalculateBlock := TRUE;
  RETURN;

 ELSIF (ValidProfileCount = 4)
 THEN
  idx_else_1 := (idx_min + 1) MOD 5;
  idx_else_2 := (idx_min + 2) MOD 5;
  idx_else_3 := (idx_min + 3) MOD 5;
  idx_else_4 := (idx_min + 4) MOD 5;
  
  IF (ValidProfiles[idx_else_1].Direction = ValidProfiles[idx_else_2].Direction)
  THEN
    AddInterval(block.a, ValidProfiles[idx_else_1], ValidProfiles[idx_else_2]);
    AddInterval(block.b, ValidProfiles[idx_else_3], ValidProfiles[idx_else_4]);
  ELSE 
    AddInterval(block.a, ValidProfiles[idx_else_1], ValidProfiles[idx_else_4]);
    AddInterval(block.b, ValidProfiles[idx_else_2], ValidProfiles[idx_else_3]);
  END_IF
  
  CalculateBlock := TRUE;
  RETURN;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Get" Id="{cec2f89e-f52b-4f5e-9994-37aa8aef2d56}">
      <Declaration><![CDATA[METHOD Get : BOOL
VAR_INPUT
  Profilefile : ProfileDesc;
END_VAR
VAR_IN_OUT
  block : Block; 
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Profilefile.SetBoundaryVelocity(p0, v0, a0, vf, af);
ValidProfileCount := -1;

IF (ABS(v0) < Constants.DoubleEpsilon AND_THEN ABS(vf) < Constants.DoubleEpsilon AND_THEN ABS(a0) < Constants.DoubleEpsilon AND_THEN ABS(af) < Constants.DoubleEpsilon)
THEN
  time_none(Profilefile, aMax, aMin, jMax);
ELSE
  time_none(Profilefile, aMax, aMin, jMax);
  time_acc0(Profilefile, aMax, aMin, jMax);
  time_none(Profilefile, aMin, aMax, -jMax);
  time_acc0(Profilefile, aMin, aMax, -jMax);
END_IF

Get := CalculateBlock(block);]]></ST>
      </Implementation>
    </Method>
    <Method Name="RemoveProfile" Id="{5312d6a5-b56f-4307-be0e-533abbe4ad96}">
      <Declaration><![CDATA[METHOD PRIVATE RemoveProfile : BOOL
VAR_INPUT
  index : INT;
END_VAR
VAR
  i : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// todo, this is pretty slow in twincat
FOR i:=index TO ValidProfileCount-2
DO
  ValidProfiles[i] := ValidProfiles[i + 1];
END_FOR

ValidProfileCount := ValidProfileCount - 1;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Set" Id="{b830671d-0c64-4c64-98a7-036c1e36cf24}">
      <Declaration><![CDATA[METHOD Set
VAR_INPUT
  p0, v0, a0 : LREAL; 
  vf, af : LREAL; 
  aMax, aMin : LREAL; 
  jMax : LREAL;   
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.p0 := p0;
THIS^.v0 := v0;
THIS^.a0 := a0;
THIS^.vf := vf;
THIS^.af := af;;
THIS^.aMax := aMax;
THIS^.aMin := aMin;
THIS^.jMax := jMax;]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc0" Id="{196de754-de31-4539-a912-55eccbd9444f}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc0
VAR_IN_OUT
  Profile : ProfileDesc;
END_VAR
VAR_INPUT
  aMax, aMin, jMax : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// UD
Profile.t[0] := (-a0 + aMax)/jMax;
Profile.t[1] := (a0*a0 + af*af - 2*aMax*aMax + 2*jMax*(vf - v0))/(2*aMax*jMax);
Profile.t[2] := (-af + aMax)/jMax;
Profile.t[3] := 0;
Profile.t[4] := 0;
Profile.t[5] := 0;
Profile.t[6] := 0;

IF (Profile.CheckForVelocity(ProfileJerkSigns.uddu, ProfileLimits.Acc0, jMax, aMax, aMin))
THEN
  AddProfile(Profile, jMax);
END_IF

// UU
Profile.t[0] := (-a0 + aMax)/jMax;
Profile.t[1] := (a0*a0 - af*af + 2*jMax*(vf - v0))/(2*aMax*jMax);
Profile.t[2] := 0;
Profile.t[3] := 0;
Profile.t[4] := (af - aMax)/jMax;
Profile.t[5] := 0;
Profile.t[6] := 0;

IF (Profile.CheckForVelocity(ProfileJerkSigns.udud, ProfileLimits.Acc0, jMax, aMax, aMin))
THEN
  AddProfile(Profile, jMax);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_none" Id="{f88d49e0-16f5-403f-a899-55296e113bff}">
      <Declaration><![CDATA[METHOD PRIVATE time_none
VAR_IN_OUT
  Profile : ProfileDesc;
END_VAR
VAR_INPUT
  aMax, aMin, jMax : LREAL;
END_VAR
VAR
  h1 : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[h1 := (a0*a0 + af*af)*0.5 + jMax*(vf - v0);
IF h1>=0
THEN
  h1 := SQRT(h1);
  
  // Solution 1
  Profile.t[0] := -(a0 + h1)/jMax;
  Profile.t[1] := 0;
  Profile.t[2] := -(af + h1)/jMax;
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := 0;
  
  IF (Profile.CheckForVelocity(ProfileJerkSigns.uddu, ProfileLimits.None, jMax, aMax, aMin))
  THEN
    AddProfile(Profile, jMax);
    RETURN;
  END_IF

  // Solution 2
  Profile.t[0] := (-a0 + h1)/jMax;
  Profile.t[1] := 0;
  Profile.t[2] := (-af + h1)/jMax;
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := 0;
  
  IF (Profile.CheckForVelocity(ProfileJerkSigns.uddu, ProfileLimits.None, jMax, aMax, aMin)) THEN
    AddProfile(Profile, jMax);
  END_IF

END_IF
    ]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>