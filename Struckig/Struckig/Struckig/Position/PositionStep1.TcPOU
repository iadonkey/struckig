<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="PositionStep1" Id="{59242074-56b3-4cce-98f4-96108527bef2}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK INTERNAL PositionStep1
VAR
  p0, v0, a0 : LREAL;
  pf, vf, af : LREAL;
  vMax, vMin, aMax, aMin, jMax : LREAL;

  // Pre-calculated expressions
  pd_ : LREAL;
  v0_v0, vf_vf : LREAL;
  a0_a0, a0_p3, a0_p4, a0_p5, a0_p6 : LREAL;
  af_af, af_p3, af_p4, af_p5, af_p6 : LREAL;
  jMax_jMax : LREAL;
  
  // runtime  calculated expressions
  polynom : ARRAY[0..4] OF LREAL;
  orig : LREAL;
  deriv : LREAL;
  t : LREAL;
  i : INT;
  h0, h1, h2 : LREAL;
  
  
  
  has_up_vel, has_down_vel : BOOL;
  validProfiles : ARRAY[0..5] OF ProfileDesc; // Max 5 valid profiles + 1 spare for numerical issues
  validProfileCounter : INT := -1;
  
  rootCount : INT;
  root : ARRAY[0..6] OF LREAL;
  left_duration, right_duration : LREAL;   
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="AddInterval" Id="{f04cf183-f22e-4a08-854f-8d9fd235e3cd}">
      <Declaration><![CDATA[METHOD AddInterval
VAR_INPUT
  interval : REFERENCE TO BlockInterval;
  Left : REFERENCE TO ProfileDesc;
  Right : REFERENCE TO ProfileDesc;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[left_duration := Left.t_sum[6] + Left.t_brake;
right_duration := Right.t_sum[6] + Right.t_brake;
IF (left_duration < right_duration)
THEN
  interval.Left := left_duration;
  interval.Right := right_duration;
  interval.Profile := Right;
  interval.IsUsed := TRUE;
ELSE
  interval.Left := right_duration;
  interval.Right := left_duration;
  interval.Profile := Left;
  interval.IsUsed := TRUE;  
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddProfile" Id="{443ac9a1-c2c8-4422-873c-d80f090e8e87}">
      <Declaration><![CDATA[METHOD AddProfile
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  jMax : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Profile.Direction := SEL((jMax > 0), ProfileDirection.Down, ProfileDirection.Up);

IF (Profile.Limits = ProfileLimits.Acc0Acc1Vel OR_ELSE Profile.Limits = ProfileLimits.Acc0Vel OR_ELSE Profile.Limits = ProfileLimits.Acc1Vel OR_ELSE Profile.Limits = ProfileLimits.Vel)
THEN
    CASE (Profile.Direction)
    OF
      ProfileDirection.Up: has_up_vel := TRUE;
      ProfileDirection.Down: has_down_vel := TRUE;
    END_CASE        
END_IF

validProfileCounter := validProfileCounter + 1;
validProfiles[validProfileCounter] := Profile;]]></ST>
      </Implementation>
    </Method>
    <Method Name="CalculateBlock" Id="{50e177a8-dca6-48ec-aabe-f9c22fb4f02a}">
      <Declaration><![CDATA[METHOD CalculateBlock : BOOL
VAR_INPUT
  block : REFERENCE TO Block;
END_VAR
VAR
  i, j : INT;
  Tmin : LREAL;
  idx_min : INT;
  idx_else_1, idx_else_2, idx_else_3, idx_else_4 : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF validProfileCounter = 0
THEN
  block.p_min := validProfiles[0];
  block.Tmin := block.p_min.t_sum[6] + block.p_min.t_brake;  
  CalculateBlock := TRUE;

ELSIF validProfileCounter = 1 
THEN

  IF ABS(validProfiles[0].t_sum[6] - validProfiles[1].t_sum[6]) < 8*Constants.Epsilon
  THEN
    block.p_min := validProfiles[0];
    block.Tmin := block.p_min.t_sum[6] + block.p_min.t_brake;  
    CalculateBlock := TRUE;
    RETURN;
	END_IF
  
  IF ParameterList.NumericalRobust
  THEN
    idx_min := SEL(validProfiles[0].t_sum[6] < validProfiles[1].t_sum[6], 1, 0);
    idx_else_1 := (idx_min + 1) MOD 2;

    block.p_min := validProfiles[idx_min];
    block.Tmin := block.p_min.t_sum[6] + block.p_min.t_brake;
    
    AddInterval(block.a, validProfiles[idx_min], validProfiles[idx_else_1]);
    CalculateBlock := TRUE;
    RETURN; 
	END_IF

// Only happens due to numerical issues
ELSIF (validProfileCounter = 3) 
THEN
  // Find "identical" profiles
  IF (ABS(validProfiles[0].t_sum[6] - validProfiles[1].t_sum[6]) < 32*Constants.Epsilon AND_THEN validProfiles[0].Direction <> validProfiles[1].Direction)
  THEN
    RemoveProfile(1);
  ELSIF (ABS(validProfiles[2].t_sum[6] - validProfiles[3].t_sum[6]) < 256*Constants.Epsilon  AND_THEN validProfiles[2].Direction <> validProfiles[3].Direction)
  THEN
    RemoveProfile(3);
  ELSIF (ABS(validProfiles[0].t_sum[6] - validProfiles[3].t_sum[6]) < 256*Constants.Epsilon AND_THEN validProfiles[0].Direction <> validProfiles[3].Direction)
  THEN
    RemoveProfile(3);
  ELSE
    RETURN;
  END_IF

ELSIF ((validProfileCounter+1) MOD 2 = 0)
THEN
  RETURN;
END_IF

// Find index of fastest Profile
Tmin := Constants.Infinity;
FOR i:=0 TO validProfileCounter
DO
  FOR j:=0 TO validProfileCounter
  DO
    IF validProfiles[i].t_sum[6] + validProfiles[i].t_brake < validProfiles[j].t_sum[6] + validProfiles[j].t_brake AND_THEN
       validProfiles[i].t_sum[6] + validProfiles[i].t_brake < Tmin
    THEN
      Tmin := validProfiles[i].t_sum[6] + validProfiles[i].t_brake;
      idx_min := i;
		END_IF
  END_FOR
END_FOR

block.a.IsUsed := FALSE;
block.b.IsUsed := FALSE;
block.p_min := validProfiles[idx_min];
block.Tmin := block.p_min.t_sum[6] + block.p_min.t_brake;  

IF (validProfileCounter = 2)
THEN
  idx_else_1 := (idx_min + 1) MOD 3;
  idx_else_2 := (idx_min + 2) MOD 3;
  
  AddInterval(block.a, validProfiles[idx_else_1], validProfiles[idx_else_2]);
  CalculateBlock := TRUE;
  RETURN;

 ELSIF (validProfileCounter = 4)
 THEN
  idx_else_1 := (idx_min + 1) MOD 5;
  idx_else_2 := (idx_min + 2) MOD 5;
  idx_else_3 := (idx_min + 3) MOD 5;
  idx_else_4 := (idx_min + 4) MOD 5;
  
  IF (validProfiles[idx_else_1].Direction = validProfiles[idx_else_2].Direction)
  THEN
    AddInterval(block.a, validProfiles[idx_else_1], validProfiles[idx_else_2]);
    AddInterval(block.b, validProfiles[idx_else_3], validProfiles[idx_else_4]);
  ELSE 
    AddInterval(block.a, validProfiles[idx_else_1], validProfiles[idx_else_4]);
    AddInterval(block.b, validProfiles[idx_else_2], validProfiles[idx_else_3]);
  END_IF
  
  CalculateBlock := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Get" Id="{1c1bdad0-f955-4d7e-82c0-f0b69b7c5251}">
      <Declaration><![CDATA[METHOD Get : BOOL
VAR_INPUT
  Profilefile : REFERENCE TO ProfileDesc;
  block : REFERENCE TO Block; 
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Profilefile.SetBoundaryPosition(p0, v0, a0, pf, vf, af);
validProfileCounter := -1;
has_up_vel := has_down_vel := FALSE;

IF (ABS(pf - p0) < Constants.DoubleEpsilon AND_THEN ABS(v0) < Constants.DoubleEpsilon AND_THEN ABS(vf) < Constants.DoubleEpsilon AND_THEN ABS(a0) < Constants.DoubleEpsilon AND_THEN ABS(af) < Constants.DoubleEpsilon)
THEN 
  IF (pf >= p0)
  THEN
    time_none(Profilefile, vMax, vMin, aMax, aMin, jMax);
  ELSE
    time_none(Profilefile, vMin, vMax, aMin, aMax, -jMax);        
  END_IF

ELSE 
  time_acc0_acc1_vel(Profilefile, vMax, vMin, aMax, aMin, jMax);
  time_acc0_acc1_vel(Profilefile, vMin, vMax, aMin, aMax, -jMax);
  time_acc1_vel(Profilefile, vMax, vMin, aMax, aMin, jMax);
  time_acc1_vel(Profilefile, vMin, vMax, aMin, aMax, -jMax);
  time_acc0_vel(Profilefile, vMax, vMin, aMax, aMin, jMax);
  time_acc0_vel(Profilefile, vMin, vMax, aMin, aMax, -jMax);
  time_vel(Profilefile, vMax, vMin, aMax, aMin, jMax);
  time_vel(Profilefile, vMin, vMax, aMin, aMax, -jMax);
  time_none(Profilefile, vMax, vMin, aMax, aMin, jMax);
  time_acc0(Profilefile, vMax, vMin, aMax, aMin, jMax);
  time_acc1(Profilefile, vMax, vMin, aMax, aMin, jMax);
  time_acc0_acc1(Profilefile, vMax, vMin, aMax, aMin, jMax);
  time_none(Profilefile, vMin, vMax, aMin, aMax, -jMax);
  time_acc0(Profilefile, vMin, vMax, aMin, aMax, -jMax);
  time_acc1(Profilefile, vMin, vMax, aMin, aMax, -jMax);
  time_acc0_acc1(Profilefile, vMin, vMax, aMin, aMax, -jMax);  

  IF (validProfileCounter = -1 OR_ELSE validProfileCounter = 1 OR_ELSE validProfileCounter = 3)
  THEN
    time_none_two_step(Profilefile, vMax, vMin, aMax, aMin, jMax);
    time_none_two_step(Profilefile, vMin, vMax, aMin, aMax, -jMax);
  END_IF
  
  IF validProfileCounter = -1 OR_ELSE validProfileCounter = 1
  THEN
    time_acc0_two_step(Profilefile, vMax, vMin, aMax, aMin, jMax);
    time_acc0_two_step(Profilefile, vMin, vMax, aMin, aMax, -jMax);
    time_vel_two_step(Profilefile, vMax, vMin, aMax, aMin, jMax);
    time_vel_two_step(Profilefile, vMin, vMax, aMin, aMax, -jMax);
    time_acc1_vel_two_step(Profilefile, vMax, vMin, aMax, aMin, jMax);
    time_acc1_vel_two_step(Profilefile, vMin, vMax, aMin, aMax, -jMax); 
  END_IF
END_IF

Get := CalculateBlock(block);]]></ST>
      </Implementation>
    </Method>
    <Method Name="RemoveProfile" Id="{bd3a75f9-6643-430d-baa6-3b74a1498442}">
      <Declaration><![CDATA[METHOD PRIVATE RemoveProfile : BOOL
VAR_INPUT
  index : INT;
END_VAR
VAR
  i : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// todo, this is pretty slow in twincat
FOR i:=index TO validProfileCounter-2
DO
  validProfiles[i] := validProfiles[i + 1];
END_FOR

validProfileCounter := validProfileCounter - 1;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Set" Id="{ce744db4-d360-45a6-a3e4-2c7d816397cb}">
      <Declaration><![CDATA[METHOD Set
VAR_INPUT
  p0, v0, a0 : LREAL;
  pf, vf, af : LREAL;
  vMax, vMin : LREAL;
  aMax, aMin : LREAL;
  jMax : LREAL;  
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.p0 := p0;
THIS^.v0 := v0;
THIS^.a0 := a0;
THIS^.pf := pf;
THIS^.vf := vf;
THIS^.af := af;
THIS^.vMax := vMax;
THIS^.vMin := vMin;
THIS^.aMax := aMax;
THIS^.aMin := aMin;
THIS^.jMax := jMax;

pd_ := pf - p0;

v0_v0 := v0 * v0;
vf_vf := vf * vf;

a0_a0 := a0 * a0;
af_af := af * af;

a0_p3 := a0 * a0_a0;
a0_p4 := a0_a0 * a0_a0;
a0_p5 := a0_p3 * a0_a0;
a0_p6 := a0_p4 * a0_a0;
af_p3 := af * af_af;
af_p4 := af_af * af_af;
af_p5 := af_p3 * af_af;
af_p6 := af_p4 * af_af;

// max values needs to be invariant to plus minus sign change
jMax_jMax := jMax * jMax;]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc0" Id="{5ee3df37-2f62-4540-8c35-85e55810ddc3}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc0
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Combined UDDU and UDUD
// UDUD Strategy t7 == 0 => is equal to UDDU
polynom[0] := 1.0;
polynom[1] := (-2*aMax)/jMax;
polynom[2] := (-af_af + aMax*aMax + 2*jMax*vf)/jMax_jMax;
polynom[3] := 0;
polynom[4] := (3*(af_p4 - a0_p4) + 8*(a0_p3 - af_p3)*aMax + 24*aMax*jMax*(af*vf - a0*v0) - 6*a0_a0*(aMax*aMax - 2*jMax*v0) + 6*af_af*(aMax*aMax - 2*jMax*vf) + 12*jMax*(jMax*(vf_vf - v0_v0 - 2*aMax*pd_) - aMax*aMax*(vf - v0)))/(12*jMax_jMax*jMax_jMax);

Roots.SolveQuartMonic(ADR(polynom[1]), 4, rootCount:=rootCount, roots:=root);
FOR i:=0 TO rootCount
DO
  t := root[i];
  IF t < 0.0
  THEN
    CONTINUE;
	END_IF

  // Single Newton step (regarding pd)
  IF t > Constants.DoubleEpsilon
  THEN
    orig := (3*(af_p4 - a0_p4) + 8*(a0_p3 - af_p3)*aMax + 24*aMax*jMax*(af*vf - a0*v0) - 6*a0_a0*(aMax*aMax - 2*jMax*v0) + 6*af_af*(aMax*aMax - 2*jMax*(jMax*t*t + vf)) + 12*jMax*(-2*aMax*jMax*(pd_ + jMax*t*t*t) + aMax*aMax*(jMax*t*t + v0 - vf) + jMax*(jMax*t*t*(jMax*t*t + 2*vf) + vf_vf - v0_v0)))/(24*aMax*jMax_jMax);
    deriv := (t*(-af_af + aMax*aMax - 3*aMax*jMax*t + 2*jMax*(jMax*t*t + vf)))/aMax;
  
    IF ABS(deriv) > Constants.DoubleEpsilon
    THEN
      t := t - orig / deriv;
    END_IF
  END_IF
  
  IF ABS(deriv) < Constants.DoubleEpsilon
  THEN
    CONTINUE;
	END_IF
  
  Profile.t[0] := (-a0 + aMax)/jMax;
  Profile.t[1] := (a0_a0 - af_af + 2*jMax*((-2*aMax + jMax*t)*t + vf - v0))/(2*aMax*jMax);
  Profile.t[2] := t;
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := (af - aMax)/jMax + t;
  
  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc0, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN
    AddProfile(Profile, jMax);        
  END_IF
END_FOR   ]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc0_acc1" Id="{e5212c06-396a-492c-bc44-27957c4ab5ed}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc0_acc1
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR
VAR
  temp : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[h0 := ((3*(af_p4*aMax - a0_p4*aMin) + 8*(a0_p3 - af_p3)*aMax*aMin + 3*aMax*aMin*(aMax*aMin*(aMax - aMin) + 2*aMin*af_af - 2*aMax*a0_a0) + 12*jMax*(aMax*aMin*((aMax - 2*a0)*v0 - (aMin - 2*af)*vf) + aMin*a0_a0*v0 - aMax*af_af*vf))/(3*(aMax - aMin)*jMax_jMax) + 4*(aMax*vf_vf - aMin*v0_v0 - 2*aMin*aMax*pd_)/(aMax - aMin));
IF (h0 >= 0) // check if h1 isNan
THEN
  h1 := SQRT(h0)*ABS(jMax)/(jMax);
  // UDDU: Solution 2
  profile.t[0] := (-a0 + aMax)/jMax;
  profile.t[1] := a0_a0/(2*aMax*jMax) + (aMin - 2*aMax)/(2*jMax) - (h1 + 2*v0)/(2*aMax);
  profile.t[2] := aMax/jMax;
  profile.t[3] := 0;
  profile.t[4] := -aMin/jMax;
  profile.t[5] := -af_af/(2*aMin*jMax) - (aMax - 2*aMin)/(2*jMax) + (h1 + 2*vf)/(2*aMin);
  profile.t[6] := profile.t[4] + af/jMax;

  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc0Acc1, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN
    AddProfile(Profile, jMax);            
  END_IF
  
  // UDDU: Solution 1  
  Profile.t[0] := (-a0 + aMax)/jMax;
  Profile.t[1] := a0_a0/(2*aMax*jMax) + (aMin - 2*aMax)/(2*jMax) + (h1 - 2*v0)/(2*aMax);
  Profile.t[2] := aMax/jMax;
  Profile.t[3] := 0;
  Profile.t[4] := -aMin/jMax;
  Profile.t[5] := -af_af/(2*aMin*jMax) - (aMax - 2*aMin)/(2*jMax) - (h1 - 2*vf)/(2*aMin);
  Profile.t[6] := Profile.t[4] + af/jMax;

  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc0Acc1, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN
    AddProfile(Profile, jMax);              
  END_IF
END_IF




]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc0_acc1_vel" Id="{0932514e-6750-4a1f-b673-619a59e1903e}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc0_acc1_vel
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Profile.t[0] := (-a0 + aMax)/jMax;
Profile.t[1] := (a0_a0*0.5 - aMax*aMax - jMax*(v0 - vMax))/(aMax*jMax);
Profile.t[2] := aMax/jMax;
Profile.t[3] := (3*(a0_p4*aMin - af_p4*aMax) + 8*aMax*aMin*(af_p3 - a0_p3 + 3*jMax*(a0*v0 - af*vf)) + 6*a0_a0*aMin*(aMax*aMax - 2*jMax*v0) - 6*af_af*aMax*(aMin*aMin - 2*jMax*vf) - 12*jMax*(aMax*aMin*(aMax*(v0 + vMax) - aMin*(vf + vMax) - 2*jMax*pd_) + (aMin - aMax)*jMax*vMax*vMax + jMax*(aMax*vf_vf - aMin*v0_v0)))/(24*aMax*aMin*jMax_jMax*vMax);
Profile.t[4] := -aMin/jMax;
Profile.t[5] := -(af_af*0.5 - aMin*aMin - jMax*(vf - vMax))/(aMin*jMax);
Profile.t[6] := Profile.t[4] + af/jMax;

IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc0Acc1Vel, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
THEN
  AddProfile(Profile, jMax);    
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc0_two_step" Id="{bb72dd1e-fc6d-4110-a222-a9ef280818c2}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc0_two_step
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ABS(2*a0*jMax) > Constants.Epsilon
THEN
  // Two step
  Profile.t[0] := 0;
  Profile.t[1] := (af_af - a0_a0 + 2*jMax*(vf - v0))/(2*a0*jMax);
  Profile.t[2] := (a0 - af)/jMax;
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := 0;
  
  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc0, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN
    AddProfile(Profile, jMax);
    return;
  END_IF
END_IF

// TODO: recheck this
h0 := 3*(af_af - a0_a0 + 2*jMax*(v0 + vf));
h1 := 2*(2*Power2(a0_p3 + 2*af_p3 + 6*jMax_jMax*pd_ + 6*(af - a0)*jMax*vf - 3*a0*af_af) + h0*(a0_p4 - 6*a0_a0*(af_af + 2*jMax*vf) + 8*a0*(af_p3 + 3*jMax_jMax*pd_ + 3*af*jMax*vf) - 3*(af_p4 + 4*af_af*jMax*vf + 4*jMax_jMax*(vf_vf - v0_v0))));
IF h1 >= 0 AND_THEN ABS(h0) > Constants.DoubleEpsilon
THEN
  h1 := SQRT(h1) * ABS(jMax) / jMax;
  
  // Three step
  Profile.t[0] := (4*af_p3 + 2*a0_p3 - 6*a0*af_af + 12*jMax_jMax*pd_ + 12*(af - a0)*jMax*vf + h1)/(2*jMax*h0);
  Profile.t[1] := -h1/(jMax*h0);
  Profile.t[2] := (-4*a0_p3 - 2*af_p3 + 6*a0_a0*af + 12*jMax_jMax*pd_ - 12*(af - a0)*jMax*v0 + h1)/(2*jMax*h0);
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := 0;
  
  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc0, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN
    AddProfile(Profile, jMax);
    RETURN;     
  END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc0_vel" Id="{d92ea80d-f7d7-4e3b-b992-468587be1c31}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc0_vel
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ((jMax > 0 AND_THEN has_up_vel) OR_ELSE (jMax < 0 AND_THEN has_down_vel)) 
THEN
  RETURN;    
END_IF

h1 := SQRT(0.5*af_af/(jMax_jMax) + (vMax - vf)/jMax);

Profile.t[0] := (-a0 + aMax)/jMax;
Profile.t[1] := (a0_a0*0.5 - aMax*aMax - jMax*(v0 - vMax))/(aMax*jMax);
Profile.t[2] := aMax/jMax;
Profile.t[3] := (3*a0_p4 + 8*(af_p3 - a0_p3)*aMax + 24*aMax*jMax*(a0*v0 - af*vf) + 6*a0_a0*(aMax*aMax - 2*jMax*v0) - 12*jMax*(-2*aMax*jMax*pd_ + aMax*aMax*(v0 + vMax) + jMax*(vMax*vMax - v0_v0) + (2*(vf + vMax)*jMax - af_af)*aMax*h1))/(24*aMax*jMax_jMax*vMax);
Profile.t[4] := h1;
Profile.t[5] := 0;
Profile.t[6] := Profile.t[4] + af/jMax;

IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc0Vel, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE)) 
THEN
  AddProfile(Profile, jMax);    
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc1" Id="{6fa9f1fb-2a10-4190-9e2d-428719e15794}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc1
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[polynom[0] := 1.0;
polynom[1] := (2*(2*a0 - aMin))/jMax;
polynom[2] := (5*a0_a0 - 6*a0*aMin + aMin*aMin + 2*jMax*v0)/jMax_jMax;
polynom[3] := (2*(a0 - aMin)*(a0_a0 - a0*aMin + 2*jMax*v0))/(jMax_jMax*jMax);
polynom[4] := (3*(a0_p4 - af_p4) - 8*(a0_p3 - af_p3)*aMin - 24*aMin*jMax*(a0*v0 + af*vf) + 6*a0_a0*(aMin*aMin + 2*jMax*v0) - 6*af_af*(aMin*aMin - 2*jMax*vf) + 12*jMax*(2*aMin*jMax*pd_ + aMin*aMin*(v0 + vf) + jMax*(v0_v0 - vf_vf)))/(12*jMax_jMax*jMax_jMax);

Roots.SolveQuartMonic(ADR(polynom[1]), 4, rootCount:=rootCount, roots:=root);
FOR i:=0 TO rootCount
DO
  t := root[i];
  IF t < 0.0
  THEN
    CONTINUE;
	END_IF

  IF t > Constants.DoubleEpsilon
  THEN
    // Double Newton step (regarding pd)
    h1 := jMax*t*t + v0;
    orig := -pd_ + (3*(a0_p4 - af_p4) + 8*af_p3*aMin + 8*a0_p3*(-aMin + 3*jMax*t) + 24*a0*jMax*(-aMin + 2*jMax*t)*(-aMin*t + h1) + 6*a0_a0*(aMin*aMin + 2*jMax*(-4*aMin*t + 5*h1 - 4*v0)) - 24*af*aMin*jMax*vf - 6*af_af*(aMin*aMin - 2*jMax*vf) + 12*jMax*(-2*aMin*jMax*t*(h1 + v0) + aMin*aMin*(h1 + vf) + jMax*(h1*h1 - vf_vf)))/(-24*aMin*jMax_jMax);
    deriv := -((a0 - aMin + jMax*t)*(a0_a0 - aMin*jMax*t + a0*(-aMin + 4*jMax*t) + 2*jMax*h1))/(aMin*jMax);
    
    IF ABS(deriv) > Constants.DoubleEpsilon
    THEN
      t := t - MIN(orig / deriv, t);
      
      h1 := jMax*t*t + v0;
      orig := -pd_ + (3*(a0_p4 - af_p4) + 8*af_p3*aMin + 8*a0_p3*(-aMin + 3*jMax*t) + 24*a0*jMax*(-aMin + 2*jMax*t)*(-aMin*t + h1) + 6*a0_a0*(aMin*aMin + 2*jMax*(-4*aMin*t + 5*h1 - 4*v0)) - 24*af*aMin*jMax*vf - 6*af_af*(aMin*aMin - 2*jMax*vf) + 12*jMax*(-2*aMin*jMax*t*(h1 + v0) + aMin*aMin*(h1 + vf) + jMax*(h1*h1 - vf_vf)))/(-24*aMin*jMax_jMax);
      IF (ABS(orig) > 1E-9)
      THEN
        deriv := -((a0 - aMin + jMax*t)*(a0_a0 - aMin*jMax*t + a0*(-aMin + 4*jMax*t) + 2*jMax*h1))/(aMin*jMax);
        
        IF ABS(deriv) > Constants.DoubleEpsilon
        THEN
          t := t - orig / deriv; 
        END_IF
      END_IF 
    END_IF  
	END_IF

  Profile.t[0] := t;
  Profile.t[1] := 0;
  Profile.t[2] := (a0 - aMin)/jMax + t;
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := -((a0_a0 + af_af)*0.5 - aMin*aMin + jMax*t*(2*a0 + jMax*t) - jMax*(vf - v0))/(aMin*jMax);
  Profile.t[6] := (af - aMin)/jMax;
  
  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc1, jMax, vMax, vMin, aMax, aMin, setLimits:=TRUE))
  THEN
    AddProfile(Profile, jMax);
  END_IF
END_FOR   ]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc1_vel" Id="{c1122915-aa0d-4d5a-bc39-3dab8f1068c3}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc1_vel
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ((jMax > 0 AND_THEN has_up_vel) OR_ELSE (jMax < 0 AND_THEN has_down_vel)) 
THEN
  RETURN;    
END_IF

h1 := 0.5*a0_a0/(jMax_jMax) + (vMax - v0)/jMax;
IF h1 >= 0
THEN
  h1 := SQRT(h1);
  Profile.t[0] := -a0/jMax + h1;
  Profile.t[1] := 0;
  Profile.t[2] := h1;
  Profile.t[3] := -(3*af_p4 - 8*aMin*(af_p3 - a0_p3) - 24*aMin*jMax*(a0*v0 - af*vf) + 6*af_af*(aMin*aMin - 2*jMax*vf) - 12*jMax*(2*aMin*jMax*pd_ + aMin*aMin*(vf + vMax) + jMax*(vMax*vMax - vf_vf) + aMin*h1*(a0_a0 - 2*jMax*(v0 + vMax))))/(24*aMin*jMax_jMax*vMax);
  Profile.t[4] := -aMin/jMax;
  Profile.t[5] := -(af_af*0.5 - aMin*aMin + jMax*(vMax - vf))/(aMin*jMax);
  Profile.t[6] := Profile.t[4] + af/jMax;
  
  IF (ABS(Profile.t[0]) < Constants.DoubleEpsilon AND_THEN Profile.t[0] < 0.0) 
  THEN
    Profile.t[0] := 0;    
  END_IF
      
  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc1Vel, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE)) 
  THEN
    AddProfile(Profile, jMax);    
  END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc1_vel_two_step" Id="{64e54b1d-928d-4828-9fe0-4384e30cc74c}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc1_vel_two_step
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[profile.t[0] := 0;
profile.t[1] := 0;
profile.t[2] := a0/jMax;
profile.t[3] := -(3*af_p4 - 8*aMin*(af_p3 - a0_p3) - 24*aMin*jMax*(a0*v0 - af*vf) + 6*af_af*(aMin*aMin - 2*jMax*vf) - 12*jMax*(2*aMin*jMax*pd_ + aMin*aMin*(vf + vMax) + jMax*(vMax*vMax - vf_vf) + aMin*a0*(a0_a0 - 2*jMax*(v0 + vMax))/jMax))/(24*aMin*jMax_jMax*vMax);
profile.t[4] := -aMin/jMax;
profile.t[5] := -(af_af/2 - aMin*aMin + jMax*(vMax - vf))/(aMin*jMax);
profile.t[6] := profile.t[4] + af/jMax;

IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc1Vel, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
THEN
  AddProfile(Profile, jMax);
  RETURN;        
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_none" Id="{8dc73406-0d3d-47dc-bb3e-7f48cc7640c3}">
      <Declaration><![CDATA[METHOD PRIVATE time_none
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;  
  vMax : LREAL;
  vMin : LREAL;  
  aMax : LREAL;
  aMin : LREAL;
  jMax : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// UDDU
IF (ABS(v0) < Constants.DoubleEpsilon AND_THEN ABS(a0) < Constants.DoubleEpsilon AND_THEN ABS(vf) < Constants.DoubleEpsilon AND_THEN ABS(af) < Constants.DoubleEpsilon)
THEN
  Profile.t[0] := Cbrt(0.5 * pd_/jMax);
  Profile.t[1] := 0;
  Profile.t[2] := 2*Profile.t[0];
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := Profile.t[0];
  
  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.None, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN
    AddProfile(Profile, jMax); 
    RETURN;            
  END_IF
END_IF

        
IF (ABS(a0 - af) < Constants.DoubleEpsilon AND_THEN ABS(v0 + vf) < Constants.DoubleEpsilon AND_THEN ABS(p0 - pf) < Constants.DoubleEpsilon) 
THEN
  h1 := SQRT(a0_a0 - 2*jMax*v0);

  // Solution 3
  Profile.t[0] := -(a0 + h1)/jMax;
  Profile.t[1] := 0;
  Profile.t[2] := Profile.t[0];
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := 0;

  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.None, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN
    AddProfile(Profile, jMax);                
  END_IF
        
  // Solution 4
  Profile.t[0] := -(a0 - h1)/jMax;
  Profile.t[1] := 0;
  Profile.t[2] := Profile.t[0];
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := 0;

  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.None, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN
    AddProfile(Profile, jMax);                
  END_IF
        
  RETURN;        
END_IF

// UDDU / UDUD modern, this one is in particular prone to numerical issues
// UDUD Strategy: t7 == 0 (equals UDDU)
h2 := (a0_a0 - af_af + 2*jMax*(vf - v0))/(2*jMax_jMax);
polynom[0] := 1.0;
polynom[1] := 0.0;
polynom[2] := (-2*(a0_a0 + af_af - 2*jMax*(v0 + vf)))/jMax_jMax;
polynom[3] := (4*(a0_p3 - af_p3 + 3*jMax*(af*vf - a0*v0 - jMax*pd_)))/(3*jMax*jMax_jMax);
polynom[4] := -h2*h2;
Roots.SolveQuartMonic(ADR(polynom[1]), 4, rootCount:=rootCount, roots:=root);
FOR i:=0 TO rootCount
DO
  t := root[i];
  IF t <= 0.0
  THEN
    CONTINUE;
	END_IF
            
  // Single Newton-step (regarding pd)
  h1 := (a0_a0 - af_af)/(2*jMax) + (vf - v0);
  orig := (-h1*h1 + 4*h1*t*(af + jMax*t))/(4*jMax*t) + (4*a0_p3 + 2*af_p3 - 6*a0_a0*(af + 2*jMax*t) + 12*(af - a0)*jMax*v0 + 3*jMax_jMax*(-4*pd_ + jMax*t*t*t + 8*t*v0))/(12*jMax_jMax);
  deriv := h1 + 2*v0 - a0_a0/jMax + h1*h1/(4*jMax*t*t) + (3*jMax*t*t)/4;
  
  IF ABS(deriv) < Constants.DoubleEpsilon
  THEN
    CONTINUE;
	END_IF
  
  t := t - orig / deriv;

  h0 := ((a0_a0 - af_af)/jMax + 2*(vf - v0))/(4*jMax*t);
  Profile.t[0] := h0 + t*0.5 - a0/jMax;
  Profile.t[1] := 0;
  Profile.t[2] := t;
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := -h0 + t*0.5 + af/jMax;

  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.None, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE)) 
  THEN
    AddProfile(Profile, jMax);            
  END_IF
  
END_FOR
        
    ]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_none_two_step" Id="{6056e359-3c2c-4ebb-b6ec-b0674ae1ae17}">
      <Declaration><![CDATA[METHOD PRIVATE time_none_two_step
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Two step
{}
  h0 := (a0_a0 + af_af)/2 + jMax*(vf - v0);
  IF h0 >= 0
  THEN
    h0 := SQRT(h0) * ABS(jMax) / jMax;
    profile.t[0] := (h0 - a0)/jMax;
    profile.t[1] := 0;
    profile.t[2] := (h0 - af)/jMax;
    profile.t[3] := 0;
    profile.t[4] := 0;
    profile.t[5] := 0;
    profile.t[6] := 0;
    
    IF (profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.None, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
    THEN 
      AddProfile(profile, jMax);
      RETURN;
    END_IF
	END_IF
{}
  
  // Single step
{}
  profile.t[0] := (af - a0)/jMax;
  profile.t[1] := 0;
  profile.t[2] := 0;
  profile.t[3] := 0;
  profile.t[4] := 0;
  profile.t[5] := 0;
  profile.t[6] := 0;
  
  IF (profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.None, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN 
    AddProfile(profile, jMax);
    RETURN;
  END_IF
{}]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_vel" Id="{25fee1d9-95b1-4ca4-a757-3e8d197e37fa}">
      <Declaration><![CDATA[METHOD PRIVATE time_vel
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[h1 := af_af/(2*jMax_jMax) + (vMax - vf)/jMax;
h2 := a0_a0/(2*jMax_jMax) + (vMax - v0)/jMax;

IF h1 >= 0 AND_THEN h2 >= 0
THEN
  h1 := SQRT(h1);
  h2 := SQRT(h2);
  
  IF ((jMax > 0 AND_THEN has_up_vel) OR_ELSE (jMax < 0 AND_THEN has_down_vel))
  THEN
    RETURN;
  END_IF
  
  // Solution 3/4
  Profile.t[0] := h2 - a0/jMax;
  Profile.t[1] := 0;
  Profile.t[2] := h2;
  Profile.t[3] := (af_p3 - a0_p3)/(3.0*jMax_jMax*vMax) + (a0*v0 - af*vf + (af_af*h1 + a0_a0*h2)*0.5)/(jMax*vMax) - (v0/vMax + 1.0)*h2 - (vf/vMax + 1.0)*h1 + pd_/vMax;
  Profile.t[4] := h1;
  Profile.t[5] := 0;
  Profile.t[6] := h1 + af/jMax;
  
  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Vel, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN
    AddProfile(Profile, jMax);
  END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_vel_two_step" Id="{78d50b14-2a01-494d-b78f-ace6c4afe469}">
      <Declaration><![CDATA[METHOD PRIVATE time_vel_two_step
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Four step
{}
  h1 := af_af/(2*jMax_jMax) + (vMax - vf)/jMax;
  IF h1 >= 0
  THEN
    h1 := SQRT(h1);
  
    // Solution 3/4
    profile.t[0] := -a0/jMax;
    profile.t[1] := 0;
    profile.t[2] := 0;
    profile.t[3] := (af_p3 - a0_p3)/(3*jMax_jMax*vMax) + (a0*v0 - af*vf + (af_af*h1)/2)/(jMax*vMax) - (vf/vMax + 1.0)*h1 + pd_/vMax;
    profile.t[4] := h1;
    profile.t[5] := 0;
    profile.t[6] := h1 + af/jMax;
  
    IF Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Vel, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE)
    THEN
      addProfile(profile, jMax);
      RETURN;
    END_IF
  END_IF  
{}

{}
  h1 := af_af/(2*jMax_jMax) + (vMax - vf)/jMax;
  IF h1>=0
  THEN
    h1 := SQRT(h1);
    
    // Four step        
    Profile.t[0] := 0;
    Profile.t[1] := 0;
    Profile.t[2] := a0/jMax;
    Profile.t[3] := (af_p3 - a0_p3)/(3.0*jMax_jMax*vMax) + (a0*v0 - af*vf + (af_af*h1 + a0_p3/jMax)*0.5)/(jMax*vMax) - (v0/vMax + 1.0)*a0/jMax - (vf/vMax + 1.0)*h1 + pd_/vMax;
    Profile.t[4] := h1;
    Profile.t[5] := 0;
    Profile.t[6] := h1 + af/jMax;
    
    IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Vel, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
    THEN
      AddProfile(Profile, jMax); 
      RETURN;       
    END_IF
  END_IF
{}]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>