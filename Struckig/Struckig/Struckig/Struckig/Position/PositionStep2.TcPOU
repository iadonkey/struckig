<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="PositionStep2" Id="{76034b67-20c8-4cde-bd76-8a31c34aeac6}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK INTERNAL PositionStep2
VAR
  v0, a0 : LREAL;
  tf, vf, af : LREAL;
  _vMax, _vMin, _aMax, _aMin, _jMax : LREAL;
  
  // Pre-calculated expressions
  pd : LREAL;
  tf_tf, tf_p3, tf_p4 : LREAL;
  vd, vd_vd : LREAL;
  ad, ad_ad : LREAL;
  v0_v0, vf_vf : LREAL;
  a0_a0, a0_p3, a0_p4, a0_p5, a0_p6 : LREAL;
  af_af, af_p3, af_p4, af_p5, af_p6 : LREAL;
  jMax_jMax : LREAL;
  g1, g2 : LREAL;
  t_min, t_max : LREAL;
  up_first : BOOL;
  
  d_extremasCount : INT;
  d_extremas : ARRAY[0..6] OF LREAL;
  indices : ARRAY[0..6] OF INT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="Get" Id="{dbdd6792-f17f-427d-b490-a17c4aa900bf}">
      <Declaration><![CDATA[METHOD Get : BOOL
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
END_VAR
VAR_INST
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[up_first := (pd > tf * v0);
vMax := SEL(up_first, _vMin, _vMax);
vMin := SEL(up_first, _vMax, _vMin);
aMax := SEL(up_first, _aMin, _aMax);
aMin := SEL(up_first, _aMax, _aMin);
jMax := SEL(up_first, -_jMax, _jMax);

Get := time_acc0_acc1_vel(profile, vMax, vMin, aMax, aMin, jMax)
    OR_ELSE time_vel(profile, vMax, vMin, aMax, aMin, jMax)
    OR_ELSE time_acc0_vel(profile, vMax, vMin, aMax, aMin, jMax)
    OR_ELSE time_acc1_vel(profile, vMax, vMin, aMax, aMin, jMax)
    OR_ELSE time_acc0_acc1(profile, vMax, vMin, aMax, aMin, jMax)
    OR_ELSE time_acc0(profile, vMax, vMin, aMax, aMin, jMax)
    OR_ELSE time_acc1(profile, vMax, vMin, aMax, aMin, jMax)
    OR_ELSE time_none(profile, vMax, vMin, aMax, aMin, jMax)
    OR_ELSE time_acc0_acc1_vel(profile, vMin, vMax, aMin, aMax, -jMax)
    OR_ELSE time_vel(profile, vMin, vMax, aMin, aMax, -jMax)
    OR_ELSE time_acc0_vel(profile, vMin, vMax, aMin, aMax, -jMax)
    OR_ELSE time_acc1_vel(profile, vMin, vMax, aMin, aMax, -jMax)
    OR_ELSE time_acc0_acc1(profile, vMin, vMax, aMin, aMax, -jMax)
    OR_ELSE time_acc0(profile, vMin, vMax, aMin, aMax, -jMax)
    OR_ELSE time_acc1(profile, vMin, vMax, aMin, aMax, -jMax)
    OR_ELSE time_none(profile, vMin, vMax, aMin, aMax, -jMax);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Set" Id="{9a678141-8adf-4fac-8bc9-7fab52b65245}">
      <Declaration><![CDATA[METHOD Set
VAR_INPUT
  tf : LREAL;
  p0, v0, a0 : LREAL;
  pf, vf, af : LREAL;
  vMax, vMin : LREAL;
  aMax, aMin : LREAL;
  jMax : LREAL;  
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.v0 := v0;
THIS^.a0 := a0;
THIS^.tf := tf;
THIS^.vf := vf;
THIS^.af := af;
THIS^._vMax := vMax;
THIS^._vMin := vMin;
THIS^._aMax := aMax;
THIS^._aMin := aMin;
THIS^._jMax := jMax;

pd := pf - p0;
tf_tf := tf * tf;
tf_p3 := tf_tf * tf;
tf_p4 := tf_tf * tf_tf;

vd := vf - v0;
vd_vd := vd * vd;
v0_v0 := v0 * v0;
vf_vf := vf * vf;

ad := af - a0;
ad_ad := ad * ad;
a0_a0 := a0 * a0;
af_af := af * af;

a0_p3 := a0 * a0_a0;
a0_p4 := a0_a0 * a0_a0;
a0_p5 := a0_p3 * a0_a0;
a0_p6 := a0_p4 * a0_a0;
af_p3 := af * af_af;
af_p4 := af_af * af_af;
af_p5 := af_p3 * af_af;
af_p6 := af_p4 * af_af;

// max values needs to be invariant to plus minus sign change
jMax_jMax := jMax * jMax;

g1 := -pd + tf*v0;
g2 := -2*pd + tf*(v0 + vf);]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc0" Id="{fd50728d-a338-4ba0-890f-9981830b852f}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc0 : BOOL
VAR_IN_OUT
  Profile : ProfileDesc;
END_VAR
VAR_INPUT
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR
VAR
  h0, h0a, h0b, h0c, h1, h2 : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[h1 := SQRT(ad_ad/(2*jMax_jMax) - ad*(aMax - a0)/(jMax_jMax) + (aMax*tf - vd)/jMax);

Profile.t[0] := (aMax - a0)/jMax;
Profile.t[1] := tf - ad/jMax - 2*h1;
Profile.t[2] := h1;
Profile.t[3] := 0;
Profile.t[4] := (af - aMax)/jMax + h1;
Profile.t[5] := 0;
Profile.t[6] := 0;

time_acc0 := profile.CheckWithTiming(ProfileJerkSigns.Udud, ProfileLimits.None, tf, jMax, vMax, vMin, aMax, aMin);
IF time_acc0
THEN
  RETURN;
END_IF

// UDUD
h0a := -a0_a0 + af_af - 2*ad*aMax + 2*jMax*(aMax*tf - vd);
h0b := a0_p3 + 2*af_p3 - 6*af_af*aMax - 3*a0_a0*(af - jMax*tf) - 3*a0*aMax*(aMax - 2*af + 2*jMax*tf) - 3*jMax*(jMax*(-2*pd + aMax*tf_tf + 2*tf*v0) + aMax*(aMax*tf - 2*vd)) + 3*af*(aMax*aMax + 2*aMax*jMax*tf - 2*jMax*vd);
h0 := 4*h0b*h0b - 18*h0a*h0a*h0a;
IF h0 > 0
THEN
  h0 := ABS(jMax)*SQRT(h0);
  h1 := 3*jMax*h0a;
  
  Profile.t[0] := (-a0 + aMax)/jMax;
  Profile.t[1] := (-a0_p3 + af_p3 + af_af*(-6*aMax + 3*jMax*tf) + a0_a0*(-3*af + 6*aMax + 3*jMax*tf) + 6*af*(aMax*aMax - jMax*vd) + 3*a0*(af_af - 2*(aMax*aMax + jMax*vd)) - 6*jMax*(aMax*(aMax*tf - 2*vd) + jMax*g2))/h1;
  Profile.t[2] := -(ad + h0/h1)/(2*jMax) + tf/2 - profile.t[1]/2;
  Profile.t[3] := h0/(jMax*h1);
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := tf - (Profile.t[0] + Profile.t[1] + Profile.t[2] + Profile.t[3]);
  
  time_acc0 := profile.CheckWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.None, tf, jMax, vMax, vMin, aMax, aMin);
  IF time_acc0
  THEN
    RETURN;
  END_IF
END_IF



// a3 != 0
// UDDU Solution 1
h0a := a0_p3 + 2*af_p3 - 6*(af_af + aMax*aMax)*aMax - 6*(a0 + af)*aMax*jMax*tf + 9*aMax*aMax*(af + jMax*tf) + 3*a0*aMax*(-2*af + 3*aMax) + 3*a0_a0*(af - 2*aMax + jMax*tf) - 6*jMax_jMax*g1 + 6*(af - aMax)*jMax*vd - 3*aMax*jMax_jMax*tf_tf;
h0b := a0_a0 + af_af + 2*(aMax*aMax - (a0 + af)*aMax + jMax*(vd - aMax*tf));
h1 := 4*h0a*h0a - 18*h0b*h0b*h0b;
IF h1 >= 0
THEN
  h1 := ABS(jMax)/jMax*SQRT(h1);
  h2 := 6*jMax*h0b;
  
  Profile.t[0] := (-a0 + aMax)/jMax;
  Profile.t[1] := ad/jMax - 2 * Profile.t[0] - (2*h0a - h1)/h2 + tf;
  Profile.t[2] := -(2*h0a + h1)/h2;
  Profile.t[3] := (2*h0a - h1)/h2;
  Profile.t[4] := tf - (Profile.t[0] + Profile.t[1] + Profile.t[2] + Profile.t[3]);
  Profile.t[5] := 0;
  Profile.t[6] := 0;
  
  time_acc0 := Profile.CheckWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.ACC0, tf, jMax, vMax, vMin, aMax, aMin);
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc0_acc1" Id="{7151b8f6-8f1d-455a-9e25-b504c08c7295}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc0_acc1 : BOOL
VAR_IN_OUT
  Profile : ProfileDesc;
END_VAR
VAR_INPUT
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR
VAR
  h0a : LREAL;
  h1, h2, h3, jf : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (ABS(a0) < Constants.DoubleEpsilon AND_THEN ABS(af) < Constants.DoubleEpsilon)
THEN
  h1 := 2*aMin*(-pd + tf*v0) + vd_vd + aMax*(2*pd + aMin*tf_tf - 2*tf*vf);
  h2 := ((aMax - aMin)*(-aMin*vd + aMax*(aMin*tf - vd)));

  IF h1 <> 0
  THEN
    jf := h2/h1;
    Profile.t[0] := aMax/jf;
    Profile.t[1] := (-2*aMax*h1 + aMin*aMin*(-2*pd + tf*(v0 + vf)))/h2;
    Profile.t[2] := Profile.t[0];
    Profile.t[3] := 0;
    Profile.t[4] := -aMin/jf;
    Profile.t[5] := tf - (2*Profile.t[0] + Profile.t[1] + 2*Profile.t[4]);
    Profile.t[6] := Profile.t[4];

    time_acc0_acc1 := Profile.CheckWithTiming2(ProfileJerkSigns.Uddu, ProfileLimits.Acc0Acc1, tf, jf, vMax, vMin, aMax, aMin, jMax);
    RETURN;
  END_IF
END_IF

h1 := 144*Power2((aMax - aMin)*(-aMin*vd + aMax*(aMin*tf - vd)) - af_af*(aMax*tf - vd) + 2*af*aMin*(aMax*tf - vd) + a0_a0*(aMin*tf + v0 - vf) - 2*a0*aMax*(aMin*tf - vd)) + 48*ad*(3*a0_p3 - 3*af_p3 + 12*aMax*aMin*(-aMax + aMin) + 4*af_af*(aMax + 2*aMin) + a0*(-3*af_af - 8*af*aMax + 6*aMax*aMax + 8*af*aMin + 12*aMax*aMin - 6*aMin*aMin) + 6*af*(aMax*aMax - 2*aMax*aMin - aMin*aMin) + a0_a0*(3*af - 4*(2*aMax + aMin)))*(2*aMin*(-pd + tf*v0) + vd*vd + aMax*(2*pd + aMin*tf*tf - 2*tf*vf));
IF h1 >= 0
THEN
  h1 := SQRT(h1);
  jf := -(3*af_af*aMax*tf - 3*a0_a0*aMin*tf - 6*ad*aMax*aMin*tf + 3*aMax*aMin*(aMin - aMax)*tf + 3*(a0_a0 - af_af)*vd + 6*af*aMin*vd - 6*a0*aMax*vd + 3*(aMax*aMax - aMin*aMin)*vd + h1/4)/(6*(2*aMin*(-pd + tf*v0) + vd*vd + aMax*(2*pd + aMin*tf_tf - 2*tf*vf)));
  
  IF ABS(jf) > Constants.Epsilon
  THEN
  
    Profile.t[0] := (aMax - a0)/jf;
    Profile.t[1] := (a0_a0 - af_af + 2*ad*aMin - 2*(aMax*aMax - 2*aMax*aMin + aMin*aMin + aMin*jf*tf - jf*vd))/(2*(aMax - aMin)*jf);
    Profile.t[2] := aMax/jf;
    Profile.t[3] := 0;
    Profile.t[4] := -aMin/jf;
    Profile.t[5] := tf - (Profile.t[0] + Profile.t[1] + Profile.t[2] + 2*Profile.t[4] + af/jf);
    Profile.t[6] := Profile.t[4] + af/jf;
    
    time_acc0_acc1 := Profile.CheckWithTiming2(ProfileJerkSigns.Uddu, ProfileLimits.Acc0Acc1, tf, jf, vMax, vMin, aMax, aMin, jMax);
    IF time_acc0_acc1
    THEN
      RETURN;
    END_IF
  
	END_IF  
END_IF


// Profile UDDU, Solution 1
{}
  profile.t[0] := (-a0 + aMax)/jMax;
  profile.t[1] := -((af_af - a0_a0)/2 + aMax*aMax + aMin*aMin - ad*aMin - 2*aMax*aMin + jMax*(aMin*tf - vd))/((aMax - aMin)*jMax);
  profile.t[2] := aMax/jMax;
  profile.t[3] := 0;
  profile.t[4] := -aMin/jMax;
  profile.t[5] := tf - (profile.t[0] + profile.t[1] + profile.t[2] + profile.t[3] + 2*profile.t[4] + af/jMax);
  profile.t[6] := profile.t[4] + af/jMax;
  
  time_acc0_acc1 := Profile.CheckWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.Acc0Acc1, tf, jMax, vMax, vMin, aMax, aMin);
  IF time_acc0_acc1
  THEN
    RETURN;
  END_IF
{}]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc0_acc1_vel" Id="{907b7862-6844-4d30-800e-31087180e12b}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc0_acc1_vel : BOOL
VAR_IN_OUT
  Profile : ProfileDesc;
END_VAR
VAR_INPUT
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR
VAR_INST
  h0, h1, h2, h3 : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Profile UDDU, Solution 1
IF ((2*(aMax - aMin) + ad)/jMax < tf) THEN
  h1 := (a0_p4 + af_p4 - 4*a0_p3*(2*aMax + aMin)/3 - 4*af_p3*(aMax + 2*aMin)/3 + 2*(a0_a0 - af_af)*aMax*aMax + (4*a0*aMax - 2*a0_a0)*(af_af - 2*af*aMin + (aMin - aMax)*aMin + 2*jMax*(aMin*tf - vd)) + 2*af_af*(aMin*aMin + 2*jMax*(aMax*tf - vd)) + 4*jMax*(2*aMin*(af*vd + jMax*g1) + (aMax*aMax - aMin*aMin)*vd + jMax*vd_vd) + 8*aMax*jMax_jMax*(pd - tf*vf))/(aMax*aMin) + 4*af_af + 2*a0_a0 + (4*af + aMax - aMin)*(aMax - aMin) + 4*jMax*(aMin - aMax + jMax*tf - 2*af)*tf;
  IF h1 >= 0
  THEN
    h1 := SQRT(h1) * ABS(jMax)/jMax;
    
    Profile.t[0] := (-a0 + aMax)/jMax;
    Profile.t[1] := (-(af_af - a0_a0 + 2*aMax*aMax + aMin*(aMin - 2*ad - 3*aMax) + 2*jMax*(aMin*tf - vd)) + aMin*h1)/(2*(aMax - aMin)*jMax);
    Profile.t[2] := aMax/jMax;
    Profile.t[3] := (aMin - aMax + h1)/(2*jMax);
    Profile.t[4] := -aMin/jMax;
    Profile.t[5] := tf - (Profile.t[0] + Profile.t[1] + Profile.t[2] + Profile.t[3] + 2*Profile.t[4] + af/jMax);
    Profile.t[6] := Profile.t[4] + af/jMax;
    
    time_acc0_acc1_vel := Profile.CheckWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.Acc0Acc1Vel, tf, jMax, vMax, vMin, aMax, aMin);
    IF time_acc0_acc1_vel
    THEN
      RETURN;
    END_IF
  END_IF
END_IF

// Profile UDUD
Profile.t[1] := (3*(a0_p4 + af_p4) - 4*(a0_p3 + af_p3)*aMax - 4*af_p3*aMax + 24*(a0 + af)*aMax*aMax*aMax - 6*(af_af + a0_a0)*(aMax*aMax - 2*jMax*vd) + 6*a0_a0*(af_af - 2*af*aMax - 2*aMax*jMax*tf) - 12*aMax*aMax*(2*aMax*aMax - 2*aMax*jMax*tf + jMax*vd) - 24*af*aMax*jMax*vd + 12*jMax_jMax*(2*aMax*g1 + vd_vd))/(12*aMax*jMax*(a0_a0 + af_af - 2*(a0 + af)*aMax + 2*(aMax*aMax - aMax*jMax*tf + jMax*vd)));
Profile.t[2] := aMax/jMax;
Profile.t[3] := (-a0_a0 - af_af + 2*aMax*(a0 + af - 2*aMax) - 2*jMax*vd)/(2*aMax*jMax) + tf;
Profile.t[4] := Profile.t[2];
Profile.t[5] := tf - (Profile.t[0] + Profile.t[1] + Profile.t[2] + Profile.t[3] + 2*Profile.t[4] - af/jMax);
Profile.t[6] := Profile.t[4] - af/jMax;

time_acc0_acc1_vel := Profile.CheckWithTiming(ProfileJerkSigns.Udud, ProfileLimits.Acc0Acc1Vel, tf, jMax, vMax, vMin, aMax, aMin);]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc0_vel" Id="{525f27d2-ae9a-4ac9-8442-eb549f9bf992}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc0_vel : BOOL
VAR_IN_OUT
  Profile : ProfileDesc;
END_VAR
VAR_INPUT
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR
VAR
  ph1, ph2, ph3, ph4 : LREAL;
  polynom : ARRAY[0..4] OF LREAL;
  t : LREAL; 
  orig, deriv : LREAL;
  h1 : LREAL;
  i : INT;  
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (tf < MAX((-a0 + aMax)/jMax, 0.0) + MAX(aMax/jMax, 0.0))
THEN
  RETURN;
END_IF

ph1 := 12*jMax*(-aMax*aMax*vd - jMax*vd_vd + 2*aMax*jMax*(-pd + tf*vf));

polynom[0] := (2*aMax)/jMax;
polynom[1] := (a0_a0 - af_af + 2*ad*aMax + aMax*aMax + 2*jMax*(vd - aMax*tf))/jMax_jMax;
polynom[2] := 0;
polynom[3] := -(-3*(a0_p4 + af_p4) + 4*(af_p3 + 2*a0_p3)*aMax - 12*a0*aMax*(af_af - 2*jMax*vd) + 6*a0_a0*(af_af - aMax*aMax - 2*jMax*vd) + 6*af_af*(aMax*aMax - 2*aMax*jMax*tf + 2*jMax*vd) + ph1)/(12*jMax_jMax*jMax_jMax);

t_min := -af/jMax;
t_max := MIN(tf - aMax/jMax, -aMin/jMax);
        
Roots.SolveQuartMonic(ADR(polynom), 4, rootCount:=d_extremasCount, roots:=d_extremas);
FOR i:=0 TO d_extremasCount
DO
  t := d_extremas[i];
  IF t < t_min OR_ELSE t > t_max
  THEN
    CONTINUE;
  END_IF

  // Single Newton step (regarding pd)
  IF (t > Constants.DoubleEpsilon)
  THEN
    h1 := jMax*t*t + vd;
    orig := (-3*(a0_p4 + af_p4) + 4*(af_p3 + 2*a0_p3)*aMax - 24*af*aMax*jMax_jMax*t*t - 12*a0*aMax*(af_af - 2*jMax*h1) + 6*a0_a0*(af_af - aMax*aMax - 2*jMax*h1) + 6*af_af*(aMax*aMax - 2*aMax*jMax*tf + 2*jMax*h1) - 12*jMax*(aMax*aMax*h1 + jMax*h1*h1 + 2*aMax*jMax*(pd + jMax*t*t*(t - tf) - tf*vf)))/(24*aMax*jMax_jMax);                
    deriv := -t*(a0_a0 - af_af + 2*aMax*(ad - jMax*tf) + aMax*aMax + 3*aMax*jMax*t + 2*jMax*h1)/aMax;
  
    IF ABS(deriv) < Constants.DoubleEpsilon
    THEN
      CONTINUE;
    END_IF  

    t := t - orig / deriv;	  
  END_IF


  h1 := ((a0_a0 - af_af)*0.5 + jMax*(jMax*t*t + vd))/aMax;

  Profile.t[0] := (-a0 + aMax)/jMax;
  Profile.t[1] := (h1 - aMax)/jMax;
  Profile.t[2] := aMax/jMax;
  Profile.t[3] := tf - (h1 + ad + aMax)/jMax - 2*t;
  Profile.t[4] := t;
  Profile.t[5] := 0;
  Profile.t[6] := af/jMax + t;

  time_acc0_vel := Profile.CheckWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.Acc0Vel, tf, jMax, vMax, vMin, aMax, aMin);
  IF time_acc0_vel
  THEN
    RETURN;
  END_IF
END_FOR
        

polynom[0] := (-2*aMax)/jMax;
polynom[1] := -(a0_a0 + af_af - 2*(a0 + af)*aMax + aMax*aMax + 2*jMax*(vd - aMax*tf))/jMax_jMax;
polynom[2] := 0;
polynom[3] := (3*(a0_p4 + af_p4) - 4*(af_p3 + 2*a0_p3)*aMax + 6*a0_a0*(af_af + aMax*aMax + 2*jMax*vd) - 12*a0*aMax*(af_af + 2*jMax*vd) + 6*af_af*(aMax*aMax - 2*aMax*jMax*tf + 2*jMax*vd) - ph1)/(12*jMax_jMax*jMax_jMax);

t_min := af/jMax;
t_max := MIN(tf - (2*aMax - a0)/jMax, -aMin/jMax);
        
Roots.SolveQuartMonic(ADR(polynom), 4, rootCount:=d_extremasCount, roots:=d_extremas);
FOR i:=0 TO d_extremasCount
DO
  t := d_extremas[i];
  IF t < t_min OR_ELSE t > t_max
  THEN
    CONTINUE;
  END_IF

  // Single Newton step (regarding pd)
  h1 := jMax*t*t - vd;
  orig := -(3*(a0_p4 + af_p4) - 4*(2*a0_p3 + af_p3)*aMax + 24*af*aMax*jMax_jMax*t*t - 12*a0*aMax*(af_af - 2*jMax*h1) + 6*a0_a0*(af_af + aMax*aMax - 2*jMax*h1) + 6*af_af*(aMax*aMax - 2*jMax*(tf*aMax + h1)) + 12*jMax*(-aMax*aMax*h1 + jMax*h1*h1 - 2*aMax*jMax*(-pd + jMax*t*t*(t - tf) + tf*vf)))/(24*aMax*jMax_jMax);
  deriv := t*(a0_a0 + af_af - 2*jMax*h1 - 2*(a0 + af + jMax*tf)*aMax + aMax*aMax + 3*aMax*jMax*t)/aMax;
  
  IF ABS(deriv) < Constants.DoubleEpsilon
  THEN
    CONTINUE;
  END_IF    
  
  t := t - orig / deriv;
  
  h1 := ((a0_a0 + af_af)*0.5 + jMax*(vd - jMax*t*t))/aMax;
  Profile.t[0] := (-a0 + aMax)/jMax;
  Profile.t[1] := (h1 - aMax)/jMax;
  Profile.t[2] := aMax/jMax;
  Profile.t[3] := tf - (h1 - a0 - af + aMax)/jMax - 2*t;
  Profile.t[4] := t;
  Profile.t[5] := 0;
  Profile.t[6] := -(af/jMax) + t;

  time_acc0_vel := Profile.CheckWithTiming(ProfileJerkSigns.Udud, ProfileLimits.Acc0Vel, tf, jMax, vMax, vMin, aMax, aMin);
  IF time_acc0_vel
  THEN
    RETURN;
  END_IF
END_FOR    ]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc1" Id="{c3083484-6cc0-4b4c-b724-b4189e0984b7}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc1 : BOOL
VAR_IN_OUT
  Profile : ProfileDesc;
END_VAR
VAR_INPUT
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR
VAR
  h0, h0a, h0b, h0c, h1, h2 : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// a3 != 0
// Case UDDU
h0 := jMax_jMax*(a0_p4 + af_p4 - 4*af_p3*jMax*tf + 6*af_af*jMax_jMax*tf_tf - 4*a0_p3*(af - jMax*tf) + 6*a0_a0*(af - jMax*tf)*(af - jMax*tf) + 24*af*jMax_jMax*(-pd + tf*v0) - 4*a0*(af_p3 - 3*af_af*jMax*tf + 6*jMax_jMax*(-pd + tf*vf)) - 12*jMax_jMax*(-vd_vd + jMax*tf*(-2*pd + tf*(v0 + vf))))/3;
h1 := (a0_a0 + af_af - 2*a0*af - 2*ad*jMax*tf + 2*h0)/jMax_jMax + tf_tf;

IF h0 >= 0 AND_THEN h1 >= 0
THEN
  h0 := SQRT(h0)/jMax;
  h1 := SQRT(h1);
  
  Profile.t[0] := -(a0_a0 + af_af + 2*a0*(jMax*tf - af) - 2*jMax*vd + h0)/(2*jMax*(-ad + jMax*tf));
  Profile.t[1] := 0;
  Profile.t[2] := (tf - h1)/2 - ad/(2*jMax);
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := h1;
  Profile.t[6] := tf - (profile.t[0] + profile.t[2] + profile.t[5]);
  
  time_acc1 := Profile.CheckWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.Acc1, tf, jMax, vMax, vMin, aMax, aMin);
  IF time_acc1
  THEN
    RETURN;
  END_IF
END_IF

// Case UDUD
h0 := jMax_jMax*(a0_p4 + af_p4 + 4*(af_p3 - a0_p3)*jMax*tf + 6*af_af*jMax_jMax*tf_tf + 6*a0_a0*(af + jMax*tf)*(af + jMax*tf) + 24*af*jMax_jMax*(-pd + tf*v0) - 4*a0*(a0_a0*af + af_p3 + 3*af_af*jMax*tf + 6*jMax_jMax*(-pd + tf*vf)) + 12*jMax_jMax*(vd_vd + jMax*tf*(-2*pd + tf*(v0 + vf))))/3;
h1 := (a0_a0 + af_af - 2*a0*af + 2*ad*jMax*tf + 2*h0)/jMax_jMax + tf_tf;

IF h0 >= 0 AND_THEN h1 >= 0
THEN
  h0 := SQRT(h0)/jMax;
  h1 := SQRT(h1);
  
  Profile.t[0] := 0;
  Profile.t[1] := 0;
  Profile.t[2] := -(a0_a0 + af_af - 2*a0*af + 2*jMax*(vd - a0*tf) + h0)/(2*jMax*(ad + jMax*tf));
  Profile.t[3] := 0;
  Profile.t[4] := ad/(2*jMax) + (tf - h1)/2;
  Profile.t[5] := h1;
  Profile.t[6] := tf - (profile.t[5] + profile.t[4] + profile.t[2]);
  
  time_acc1 := profile.CheckWithTiming(ProfileJerkSigns.Udud, ProfileLimits.Acc1, tf, jMax, vMax, vMin, aMax, aMin);
  IF time_acc1
  THEN
    RETURN;
  END_IF
END_IF

// Case UDDU, Solution 2
h0a := a0_p3 - af_p3 - 3*a0_a0*aMin + 3*aMin*aMin*(a0 + jMax*tf) + 3*af*aMin*(-aMin - 2*jMax*tf) - 3*af_af*(-aMin - jMax*tf) - 3*jMax_jMax*(-2*pd - aMin*tf_tf + 2*tf*vf);
h0b := a0_a0 + af_af - 2*(a0 + af)*aMin + 2*(aMin*aMin - jMax*(-aMin*tf + vd));
h0c := a0_p4 + 3*af_p4 - 4*(a0_p3 + 2*af_p3)*aMin + 6*a0_a0*aMin*aMin + 6*af_af*(aMin*aMin - 2*jMax*vd) + 12*jMax*(2*aMin*jMax*g1 - aMin*aMin*vd + jMax*vd_vd) + 24*af*aMin*jMax*vd - 4*a0*(af_p3 - 3*af*aMin*(-aMin - 2*jMax*tf) + 3*af_af*(-aMin - jMax*tf) + 3*jMax*(-aMin*aMin*tf + jMax*(-2*pd - aMin*tf_tf + 2*tf*vf)));
h1 := 4*h0a*h0a - 6*h0b*h0c;
IF h1 >= 0
THEN
  h1 := ABS(jMax)/jMax*SQRT(h1);
  h2 := 6*jMax*h0b;
	
  Profile.t[0] := 0;
  Profile.t[1] := 0;
  Profile.t[2] := (2*h0a + h1)/h2;
  Profile.t[3] := -(a0_a0 + af_af - 2*(a0 + af)*aMin + 2*(aMin*aMin + aMin*jMax*tf - jMax*vd))/(2*jMax*(a0 - aMin - jMax*Profile.t[2]));
  Profile.t[4] := (a0 - aMin)/jMax - Profile.t[2];
  Profile.t[5] := tf - (Profile.t[2] + Profile.t[3] + Profile.t[4] + (af - aMin)/jMax);
  Profile.t[6] := (af - aMin)/jMax;
	
  time_acc1 := Profile.CheckWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.Acc1, tf, jMax, vMax, vMin, aMax, aMin);
  IF (time_acc1)
  THEN
    RETURN;
  END_IF
END_IF
    
// Case UDUD, Solution 1
h0a := -a0_p3 + af_p3 + 3*(a0_a0 - af_af)*aMax - 3*ad*aMax*aMax - 6*af*aMax*jMax*tf + 3*af_af*jMax*tf + 3*jMax*(aMax*aMax*tf + jMax*(-2*pd - aMax*tf_tf + 2*tf*vf));
h0b := a0_a0 - af_af + 2*ad*aMax + 2*jMax*(aMax*tf - vd);
h0c := a0_p4 + 3*af_p4 - 4*(a0_p3 + 2*af_p3)*aMax + 6*a0_a0*aMax*aMax - 24*af*aMax*jMax*vd + 12*jMax*(2*aMax*jMax*g1 + jMax*vd_vd + aMax*aMax*vd) + 6*af_af*(aMax*aMax + 2*jMax*vd) - 4*a0*(af_p3 + 3*af*aMax*(aMax - 2*jMax*tf) - 3*af_af*(aMax - jMax*tf) + 3*jMax*(aMax*aMax*tf + jMax*(-2*pd - aMax*tf_tf + 2*tf*vf)));
h1 := 4*h0a*h0a - 6*h0b*h0c;
IF h1 >= 0
THEN
	h1 := ABS(jMax)/jMax*SQRT(h1);
	h2 := 6*jMax*h0b;
	
	Profile.t[0] := 0;
	Profile.t[1] := 0;
	Profile.t[2] := -(2*h0a + h1)/h2;
	Profile.t[3] := 2*h1/h2;
	Profile.t[4] := (aMax - a0)/jMax + Profile.t[2];
	Profile.t[5] := tf - (Profile.t[2] + Profile.t[3] + Profile.t[4] + (-af + aMax)/jMax);
	Profile.t[6] := (-af + aMax)/jMax;
	
	time_acc1 := Profile.CheckWithTiming(ProfileJerkSigns.Udud, ProfileLimits.Acc1, tf, jMax, vMax, vMin, aMax, aMin);
	IF (time_acc1)
	THEN
	  RETURN;
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc1_vel" Id="{61921669-de39-469f-aa6e-67d4b0f84a7e}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc1_vel : BOOL
VAR_IN_OUT
  Profile : ProfileDesc;
END_VAR
VAR_INPUT
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR
VAR
  h0, ph1, ph2, ph3, ph4 : LREAL;
  polynom : ARRAY[0..3] OF LREAL; 
  t : LREAL; 
  orig, deriv : LREAL;
  h1 : LREAL;
  i : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Profile UDDU
ph1 := a0_a0 + af_af - aMin*(a0 + 2*af - aMin) - 2*jMax*(vd - aMin*tf);
ph2 := 2*aMin*(jMax*g1 + af*vd) - aMin*aMin*vd + jMax*vd_vd;
ph3 := af_af + aMin*(aMin - 2*af) - 2*jMax*(vd - aMin*tf);

polynom[0] := (2*(2*a0 - aMin))/jMax;
polynom[1] := (4*a0_a0 + ph1 - 3*a0*aMin)/jMax_jMax;
polynom[2] := (2*a0*ph1)/(jMax_jMax*jMax);
polynom[3] := (3*(a0_p4 + af_p4) - 4*(a0_p3 + 2*af_p3)*aMin + 6*af_af*(aMin*aMin - 2*jMax*vd) + 12*jMax*ph2 + 6*a0_a0*ph3)/(12*jMax_jMax*jMax_jMax);

t_min := -a0/jMax;
t_max := MIN((tf + 2*aMin/jMax - (a0 + af)/jMax)/2, (aMax - a0)/jMax);

Roots.SolveQuartMonic(ADR(polynom), 4, rootCount:=d_extremasCount, roots:=d_extremas);
FOR i:=0 TO d_extremasCount
DO
  t := d_extremas[i];
  IF t < t_min OR_ELSE t > t_max
  THEN
    CONTINUE;
  END_IF

  // Single Newton step (regarding pd)
  IF ABS(a0 + jMax*t) > 16 * Constants.DoubleEpsilon
  THEN
    h0 := jMax*t*t;
    orig := -pd + (3*(a0_p4 + af_p4) - 8*af_p3*aMin - 4*a0_p3*aMin + 6*af_af*(aMin*aMin + 2*jMax*(h0 - vd)) + 6*a0_a0*(af_af - 2*af*aMin + aMin*aMin + 2*aMin*jMax*(-2*t + tf) + 2*jMax*(5*h0 - vd)) + 24*a0*jMax*t*(a0_a0 + af_af - 2*af*aMin + aMin*aMin + 2*jMax*(aMin*(-t + tf) + h0 - vd)) - 24*af*aMin*jMax*(h0 - vd) + 12*jMax*(aMin*aMin*(h0 - vd) + jMax*(h0 - vd)*(h0 - vd)))/(24*aMin*jMax_jMax) + h0*(tf - t) + tf*v0;
    deriv := (a0 + jMax*t)*((a0_a0 + af_af)/(aMin*jMax) + (aMin - a0 - 2*af)/jMax + (4*a0*t + 2*h0 - 2*vd)/aMin + 2*tf - 3*t);
                
    IF ABS(deriv) < Constants.DoubleEpsilon
    THEN
      CONTINUE;
    END_IF    
  
    t := t - orig / deriv;
  END_IF
  
  h1 := -((a0_a0 + af_af)*0.5 + jMax*(-vd + 2*a0*t + jMax*t*t))/aMin;

  Profile.t[0] := t;
  Profile.t[1] := 0;
  Profile.t[2] := a0/jMax + t;
  Profile.t[3] := tf - (h1 - aMin + a0 + af)/jMax - 2*t;
  Profile.t[4] := -aMin/jMax;
  Profile.t[5] := (h1 + aMin)/jMax;
  Profile.t[6] := Profile.t[4] + af/jMax;

  time_acc1_vel := Profile.CheckWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.Acc1Vel, tf, jMax, vMax, vMin, aMax, aMin);
  IF time_acc1_vel
  THEN
    RETURN;
	END_IF
END_FOR



// Profile UDUD
ph1 := a0_a0 - af_af + (2*af - a0)*aMax - aMax*aMax - 2*jMax*(vd - aMax*tf);
ph2 := aMax*aMax + 2*jMax*vd;
ph3 := af_af + ph2 - 2*aMax*(af + jMax*tf);
ph4 := 2*aMax*jMax*g1 + aMax*aMax*vd + jMax*vd_vd;

polynom[0] := (4*a0 - 2*aMax)/jMax;
polynom[1] := (4*a0_a0 - 3*a0*aMax + ph1)/jMax_jMax;
polynom[2] := (2*a0*ph1)/(jMax_jMax*jMax);
polynom[3] := (3*(a0_p4 + af_p4) - 4*(a0_p3 + 2*af_p3)*aMax - 24*af*aMax*jMax*vd + 12*jMax*ph4 - 6*a0_a0*ph3 + 6*af_af*ph2)/(12*jMax_jMax*jMax_jMax);

t_min := -a0/jMax;
t_max := MIN((tf + ad/jMax - 2*aMax/jMax)/2, (aMax - a0)/jMax);
        
Roots.SolveQuartMonic(ADR(polynom), 4, rootCount:=d_extremasCount, roots:=d_extremas);
FOR i:=0 TO d_extremasCount
DO
  t := d_extremas[i];
  IF t > t_max OR_ELSE t < t_min
  THEN
    CONTINUE;
	END_IF

  h1 := ((a0_a0 - af_af)*0.5 + jMax_jMax*t*t - jMax*(vd - 2*a0*t))/aMax;

  Profile.t[0] := t;
  Profile.t[1] := 0;
  Profile.t[2] := t + a0/jMax;
  Profile.t[3] := tf + (h1 + ad - aMax)/jMax - 2*t;
  Profile.t[4] := aMax/jMax;
  Profile.t[5] := -(h1 + aMax)/jMax;
  Profile.t[6] := Profile.t[4] - af/jMax;

  time_acc1_vel := Profile.CheckWithTiming(ProfileJerkSigns.Udud, ProfileLimits.Acc1Vel, tf, jMax, vMax, vMin, aMax, aMin);
  IF time_acc1_vel
  THEN
    RETURN;
	END_IF
END_FOR


]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_none" Id="{83d242ce-3b8d-4328-b72b-2ae80162e005}">
      <Declaration><![CDATA[METHOD PRIVATE time_none : BOOL
VAR_IN_OUT
  Profile : ProfileDesc;
END_VAR
VAR_INPUT
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR
VAR
  t, h0, h1, h2, h3, orig, deriv, jf: LREAL;
  polynom : ARRAY[0..3] OF LREAL;
  i : INT;
  ph0, ph1, ph2, ph3, ph4, ph5, ph6, ph7 : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (ABS(v0) < Constants.DoubleEpsilon AND_THEN ABS(a0) < Constants.DoubleEpsilon AND_THEN ABS(af) < Constants.DoubleEpsilon)
THEN
  h1 := SQRT(tf_tf*vf_vf + (4*pd - tf*vf)*(4*pd - tf*vf));
  jf := 4*(4*pd - 2*tf*vf + h1)/tf_p3;
  
  Profile.t[0] := tf/4;
  Profile.t[1] := 0;
  Profile.t[2] := 2*Profile.t[0];
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := Profile.t[0];
  time_none := Profile.CheckWithTiming2(ProfileJerkSigns.Uddu, ProfileLimits.None, tf, jf, vMax, vMin, aMax, aMin, jMax);
  IF time_none THEN
    RETURN;
  END_IF
END_IF

h1 := 16*pd*(pd - tf*(v0 + vf)) + tf_tf*(5*v0_v0 + 6*v0*vf + 5*vf_vf);
IF (ABS(a0) < Constants.DoubleEpsilon AND_THEN ABS(af) < Constants.DoubleEpsilon) AND_THEN vd > Constants.DoubleEpsilon AND_THEN h1 >= 0
THEN
  h1 := SQRT(h1);
  jf := 4*(4*pd - 2*tf*(v0 + vf) - h1)/tf_p3;
  
  Profile.t[0] := (tf*(v0 + 3*vf) - 4*pd)/(4*vd);
  Profile.t[1] := 0;
  Profile.t[2] := tf*0.5;
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := Profile.t[4];

  time_none := Profile.CheckWithTiming2(ProfileJerkSigns.UDDU, ProfileLimits.None, tf, jf, vMax, vMin, aMax, aMin, jMax);
  IF time_none
  THEN
    RETURN;
  END_IF
END_IF


// Is that really needed?
// Profiles with a3 != 0, Solution UDDU

// First acc, then constant
polynom[0] := -2*tf;
polynom[1] := 2*vd/jMax + tf_tf;
polynom[2] := 4*(pd - tf*vf)/jMax;
polynom[3] := (vd_vd + jMax*tf*g2)/(jMax_jMax);
Roots.SolveQuartMonic(ADR(polynom), 4, rootCount:=d_extremasCount, roots:=d_extremas);
FOR i:=0 TO d_extremasCount
DO
  t := d_extremas[i];
  IF t > tf * 0.5 OR_ELSE t > (aMax - a0)/jMax
  THEN
    CONTINUE;
  END_IF

  // Single Newton step (regarding pd)
  h1 := (jMax*t*(t - tf) + vd)/(jMax*(2*t - tf));
  h2 := (2*jMax*t*(t - tf) + jMax*tf_tf - 2*vd)/(jMax*(2*t - tf)*(2*t - tf));
  orig := (-2*pd + 2*tf*v0 + h1*h1*jMax*(tf - 2*t) + jMax*tf*(2*h1*t - t*t - (h1 - t)*tf))*0.5;
  deriv := (jMax*tf*(2*t - tf)*(h2 - 1))*0.5 + h1*jMax*(tf - (2*t - tf)*h2 - h1);
  
  IF ABS(deriv) < Constants.DoubleEpsilon
  THEN
    CONTINUE;
  END_IF    
  
  t := t - orig / deriv;
  
  Profile.t[0] := t;
  Profile.t[1] := 0;
  Profile.t[2] := (jMax*t*(t - tf) + vd)/(jMax*(2*t - tf));
  Profile.t[3] := tf - 2*t;
  Profile.t[4] := t - Profile.t[2];
  Profile.t[5] := 0;
  Profile.t[6] := 0;
  
  time_none := Profile.CheckWithTiming2(ProfileJerkSigns.Uddu, ProfileLimits.None, tf, jMax, vMax, vMin, aMax, aMin, jMax);
  IF time_none
  THEN
    RETURN;
	END_IF
END_FOR


// First constant, then acc
ph1 := -jMax*(jMax*tf_tf + 4*vd);

polynom[0] := 2*jMax*(-4*pd + tf*(jMax*tf_tf - 2*v0 + 6*vf))/ph1;
polynom[1] := -(jMax_jMax*tf_p4 - 8*vd_vd + 4*jMax*tf*(-3*pd + tf*v0 + 2*tf*vf))/ph1;
polynom[2] := 4*(jMax*tf_tf*g1 - vd*(-2*pd - tf*v0 + 3*tf*vf))/ph1;
polynom[3] := -4*(jMax*g1*g1 + vd_vd*vd)/(jMax*ph1);
Roots.SolveQuartMonic(ADR(polynom), 4, rootCount:=d_extremasCount, roots:=d_extremas);
FOR i:=0 TO d_extremasCount
DO
  t := d_extremas[i];
  IF t > tf OR_ELSE t > (aMax - a0)/jMax
  THEN
    CONTINUE;
  END_IF


  // Single Newton step (regarding pd)
  h1 := (jMax*t*(t - tf) - vd)/jMax;
  IF h1 <= 0
  THEN
  	CONTINUE;
  END_IF
  
  h1 := SQRT(h1);
  orig := (-2*pd + jMax*t*(t - tf)*tf + 2*tf*v0)*0.5 - (h1*h1*h1)/jMax - t*(jMax*t*(t - tf) - vd);
  deriv := (jMax*(-2*t + tf)*(6*h1 - 2*tf) - 4*jMax*t*(3*t - 2*tf))/4 + vd;
  
  IF ABS(deriv) < Constants.DoubleEpsilon
  THEN
    CONTINUE;
  END_IF    
  
  t := t - orig / deriv;
  
  h1 := (jMax*t*(t - tf) - vd)/jMax;
  IF h1 <= 0
  THEN
  	CONTINUE;
  END_IF
  
  h1 := SQRT(h1);
  
  // Solution 2 with aPlat
  Profile.t[0] := 0;
  Profile.t[1] := 0;
  Profile.t[2] := t;
  Profile.t[3] := tf - 2*t - 2*h1;
  Profile.t[4] := h1;
  Profile.t[5] := 0;
  Profile.t[6] := tf - (t + Profile.t[3] + Profile.t[4]);
  
  time_none := Profile.CheckWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.None, tf, jMax, vMax, vMin, aMax, aMin);
  IF time_none 
  THEN
    RETURN; 
  END_IF
END_FOR

// UDUD T 0246
{}
  h0 := 2*jMax_jMax*(2*Power2(a0_p3 - af_p3 - 3*af_af*jMax*tf + 9*af*jMax_jMax*tf_tf - 3*a0_a0*(af + jMax*tf) + 3*a0*Power2(af + jMax*tf) + 3*jMax_jMax*(8*pd + jMax*tf_tf*tf - 8*tf*vf)) - 3*(a0_a0 + af_af - 2*af*jMax*tf - 2*a0*(af + jMax*tf) - jMax*(jMax*tf_tf + 4*v0 - 4*vf))*(a0_p4 + af_p4 + 4*af_p3*jMax*tf + 6*af_af*jMax_jMax*tf_tf - 3*jMax_jMax*jMax_jMax*tf_tf*tf_tf - 4*a0_p3*(af + jMax*tf) + 6*a0_a0*Power2(af + jMax*tf) - 12*af*jMax_jMax*(8*pd + jMax*tf_tf*tf - 8*tf*v0) + 48*jMax_jMax*vd_vd + 48*jMax_jMax*jMax*tf*(-2*pd + tf*(v0 + vf)) - 4*a0*(af_p3 + 3*af_af*jMax*tf - 9*af*jMax_jMax*tf_tf - 3*jMax_jMax*(8*pd + jMax*tf_tf*tf - 8*tf*vf))));
  IF h0 >= 0
  THEN
    h0 := SQRT(h0)/jMax;
    h1 := 12*jMax*(-a0_a0 - af_af + 2*af*jMax*tf + 2*a0*(af + jMax*tf) + jMax*(jMax*tf_tf + 4*v0 - 4*vf));
    h2 := -4*a0_p3 + 4*af_p3 + 12*a0_a0*af - 12*a0*af_af + 48*jMax_jMax*pd + 12*(a0_a0 - af_af)*jMax*tf - 24*jMax_jMax*tf*(v0 + vf) + 24*ad*jMax*vd;
    h3 := 2*a0_p3 - 2*af_p3 - 6*a0_a0*af + 6*a0*af_af;

    profile.t[0] := (h3 - 48*jMax_jMax*(tf*vf - pd) - 6*(a0_a0 + af_af)*jMax*tf + 12*a0*af*jMax*tf + 6*(a0 + 3*af + jMax*tf)*tf_tf*jMax_jMax - h0)/h1;
    profile.t[1] := 0;
    profile.t[2] := (h2 + h0)/h1;
    profile.t[3] := 0;
    profile.t[4] := (-h2 + h0)/h1;
    profile.t[5] := 0;
    profile.t[6] := (-h3 + 48*jMax_jMax*(tf*v0 - pd) - 6*(a0_a0 + af_af)*jMax*tf + 12*a0*af*jMax*tf + 6*(af + 3*a0 + jMax*tf)*tf_tf*jMax_jMax - h0)/h1;

    time_none := Profile.checkWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.None, tf, jMax, vMax, vMin, aMax, aMin);
    IF time_none
    THEN
      RETURN;
    END_IF
  END_IF
{}

// Profiles with a3 != 0, Solution UDDU
// T 0234
ph1 := af + jMax*tf;
polynom[0] := -2*(ad + jMax*tf)/jMax;
polynom[1] := 2*(a0_a0 + af_af + jMax*(af*tf + vd) - 2*a0*ph1)/jMax_jMax + tf_tf;
polynom[2] := 2*(a0_p3 - af_p3 - 3*af_af*jMax*tf + 3*a0*ph1*(ph1 - a0) - 6*jMax_jMax*(-pd + tf*vf))/(3*jMax_jMax*jMax);
polynom[3] := (a0_p4 + af_p4 + 4*af_p3*jMax*tf - 4*a0_p3*ph1 + 6*a0_a0*ph1*ph1 + 24*jMax_jMax*af*g1 - 4*a0*(af_p3 + 3*af_af*jMax*tf + 6*jMax_jMax*(-pd + tf*vf)) + 6*jMax_jMax*af_af*tf_tf + 12*jMax_jMax*(vd_vd + jMax*tf*g2))/(12*jMax_jMax*jMax_jMax);
Roots.SolveQuartMonic(ADR(polynom), 4, rootCount:=d_extremasCount, roots:=d_extremas);

t_min := ad/jMax;
t_max := MIN((aMax - a0)/jMax, (ad/jMax + tf) / 2);
            
FOR i:=0 TO d_extremasCount
DO
  t := d_extremas[i];
  IF t < t_min OR_ELSE t > t_max
  THEN
    CONTINUE;
	END_IF

  // Single Newton step (regarding pd)
  h0 := jMax*(2*t - tf) - ad;
  h1 := (ad_ad - 2*af*jMax*t + 2*a0*jMax*(t - tf) + 2*jMax*(jMax*t*(t - tf) + vd))/(2*jMax*h0);
  h2 := (-ad_ad + 2*jMax_jMax*(tf_tf + t*(t - tf)) + (a0 + af)*jMax*tf - ad*h0 - 2*jMax*vd)/(h0*h0);
  orig := (-a0_p3 + af_p3 + 3*ad_ad*jMax*(h1 - t) + 3*ad*jMax_jMax*(h1 - t)*(h1 - t) - 3*a0*af*ad + 3*jMax_jMax*(a0*tf_tf - 2*pd + 2*tf*v0 + h1*h1*jMax*(tf - 2*t) + jMax*tf*(2*h1*t - t*t - (h1 - t)*tf)))/(6*jMax_jMax);
  deriv := (h0*(-ad + jMax*tf)*(h2 - 1))/(2*jMax) + h1*(-ad + jMax*(tf - h1) - h0*h2);
  
  IF ABS(deriv) < Constants.DoubleEpsilon
  THEN
    CONTINUE;
	END_IF  
  
  t := t - orig / deriv;
  
  Profile.t[0] := t;
  Profile.t[1] := 0;
  Profile.t[2] := (ad_ad + 2*jMax*(-a0*tf - ad*t + jMax*t*(t - tf) + vd))/(2*jMax*(-ad + jMax*(2*t - tf)));
  Profile.t[3] := ad/jMax + tf - 2*t;
  Profile.t[4] := tf - (t + Profile.t[2] + Profile.t[3]);
  Profile.t[5] := 0;
  Profile.t[6] := 0;
  
  time_none := Profile.CheckWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.None, tf, jMax, vMax, vMin, aMax, aMin);
  IF time_none
  THEN
    RETURN; 
  END_IF
END_FOR

// T 3456
{}
  h1 := 3*jMax*(ad_ad + 2*jMax*(a0*tf - vd));
  h2 := ad_ad + 2*jMax*(a0*tf - vd);
  h0 := 4*Power2(2*(a0_p3 - af_p3) - 6*a0_a0*(af - jMax*tf) + 6*jMax_jMax*(-pd + tf*v0) + 3*a0*(2*af_af - 2*jMax*af*tf + jMax_jMax*tf_tf) + 6*ad*jMax*vd) - 18*h2*h2*h2;
  IF h0 >= 0 AND_THEN h1 <> 0
  THEN
    h0 := SQRT(h0)/h1 * ABS(jMax)/jMax;
    
    profile.t[0] := 0;
    profile.t[1] := 0;
    profile.t[2] := 0;
    profile.t[3] := (af_p3 - a0_p3 + 3*(af_af - a0_a0)*jMax*tf - 3*ad*(a0*af + 2*jMax*vd) - 6*jMax_jMax*(-2*pd + tf*(v0 + vf)))/h1;
    profile.t[4] := (tf - profile.t[3] - h0)/2 - ad/(2*jMax);
    profile.t[5] := h0;
    profile.t[6] := (tf - profile.t[3] + ad/jMax - h0)/2;
    
    time_none := Profile.checkWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.None, tf, jMax, vMax, vMin, aMax, aMin);
    IF time_none
    THEN
      RETURN;
    END_IF
	END_IF  
{}

// T 2346
ph1 := ad_ad + 2*(af + a0)*jMax*tf - jMax*(jMax*tf_tf + 4*vd);
ph2 := jMax*tf_tf*g1 - vd*(-2*pd - tf*v0 + 3*tf*vf);
ph3 := 5*af_af - 8*af*jMax*tf + 2*jMax*(2*jMax*tf_tf - vd);
ph4 := jMax_jMax*tf_p4 - 2*vd_vd + 8*jMax*tf*(-pd + tf*vf);
ph5 := (5*af_p4 - 8*af_p3*jMax*tf - 12*af_af*jMax*(jMax*tf_tf + vd) + 24*af*jMax_jMax*(-2*pd + jMax*tf_p3 + 2*tf*vf) - 6*jMax_jMax*ph4);
ph6 := -vd_vd + jMax*tf*(-2*pd + 3*tf*v0 - tf*vf) - af*g2;

polynom[0] := -(4*(a0_p3 - af_p3) - 12*a0_a0*(af - jMax*tf) + 6*a0*(2*af_af - 2*af*jMax*tf + jMax*(jMax*tf_tf - 2*vd)) + 6*af*jMax*(3*jMax*tf_tf + 2*vd) - 6*jMax_jMax*(-4*pd + jMax*tf_p3 - 2*tf*v0 + 6*tf*vf))/(3*jMax*ph1);
polynom[1] := -(-a0_p4 - af_p4 + 4*a0_p3*(af - jMax*tf) + a0_a0*(-6*af_af + 8*af*jMax*tf - 4*jMax*(jMax*tf_tf - vd)) + 2*af_af*jMax*(jMax*tf_tf + 2*vd) - 4*af*jMax_jMax*(-3*pd + jMax*tf_p3 + 2*tf*v0 + tf*vf) + jMax_jMax*(jMax_jMax*tf_p4 - 8*vd_vd + 4*jMax*tf*(-3*pd + tf*v0 + 2*tf*vf)) + 2*a0*(2*af_p3 - 2*af_af*jMax*tf + af*jMax*(-3*jMax*tf_tf - 4*vd) + jMax_jMax*(-6*pd + jMax*tf_p3 - 4*tf*v0 + 10*tf*vf)))/(jMax_jMax*ph1);
polynom[2] := -(a0_p5 - af_p5 + af_p4*jMax*tf - 5*a0_p4*(af - jMax*tf) + 2*a0_p3*ph3 + 4*af_p3*jMax*(jMax*tf_tf + vd) + 12*jMax_jMax*af*ph6 - 2*a0_a0*(5*af_p3 - 9*af_af*jMax*tf - 6*af*jMax*vd + 6*jMax_jMax*(-2*pd - tf*v0 + 3*tf*vf)) - 12*jMax_jMax*jMax*ph2 + a0*ph5)/(3*jMax_jMax*jMax*ph1);
polynom[3] := -(-a0_p6 - af_p6 + 6*a0_p5*(af - jMax*tf) - 48*af_p3*jMax_jMax*g1 + 72*jMax_jMax*jMax*(jMax*g1*g1 + vd_vd*vd + 2*af*g1*vd) - 3*a0_p4*ph3 - 36*af_af*jMax_jMax*vd_vd + 6*af_p4*jMax*vd + 4*a0_p3*(5*af_p3 - 9*af_af*jMax*tf - 6*af*jMax*vd + 6*jMax_jMax*(-2*pd - tf*v0 + 3*tf*vf)) - 3*a0_a0*ph5 + 6*a0*(af_p5 - af_p4*jMax*tf - 4*af_p3*jMax*(jMax*tf_tf + vd) + 12*jMax_jMax*(-af*ph6 + jMax*ph2)))/(18*jMax_jMax*jMax_jMax*ph1);

Roots.SolveQuartMonic(ADR(polynom), 4, rootCount:=d_extremasCount, roots:=d_extremas);
t_max := (a0 - aMin)/jMax;
FOR i:=0 TO d_extremasCount
DO
  t := d_extremas[i];
  IF t > t_max
  THEN
    CONTINUE;
  END_IF

  // Single Newton step (regarding pd)
  h1 := ad_ad/2 + jMax*(af*t + (jMax*t - a0)*(t - tf) - vd);
  h2 := -ad + jMax*(tf - 2*t);
  IF h1 < 0
  THEN
    CONTINUE;
  END_IF
  
  h3 := SQRT(h1);
  orig := (af_p3 - a0_p3 + 3*af*jMax*t*(af + jMax*t) + 3*a0_a0*(af + jMax*t) - 3*a0*(af_af + 2*af*jMax*t + jMax_jMax*(t*t - tf_tf)) + 3*jMax_jMax*(-2*pd + jMax*t*(t - tf)*tf + 2*tf*v0))/(6*jMax_jMax) - h3*h3*h3/(jMax*ABS(jMax)) + ((-ad - jMax*t)*h1)/(jMax_jMax);
  deriv := (6*jMax*h2*h3/ABS(jMax) + 2*(-ad - jMax*tf)*h2 - 2*(3*ad_ad + af*jMax*(8*t - 2*tf) + 4*a0*jMax*(-2*t + tf) + 2*jMax*(jMax*t*(3*t - 2*tf) - vd)))/(4*jMax);
  t := t - orig / deriv;
  
  h1 := 2*ad_ad + 4*jMax*(ad*t + a0*tf + jMax*t*(t - tf) - vd);
  IF h1 < 0
  THEN
    CONTINUE;
	END_IF
  
  h1 := SQRT(h1)/ABS(jMax);
  
  // Solution 2 with aPlat
  Profile.t[0] := 0;
  Profile.t[1] := 0;
  Profile.t[2] := t;
  Profile.t[3] := tf - 2*t - ad/jMax - h1;
  Profile.t[4] := h1*0.5;
  Profile.t[5] := 0;
  Profile.t[6] := tf - (t + Profile.t[3] + Profile.t[4]);
  
  time_none := Profile.CheckWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.None, tf, jMax, vMax, vMin, aMax, aMin);
  IF time_none
  THEN
    RETURN;
  END_IF
END_FOR

// Profiles with a3 != 0, Solution UDUD
// T 0124
ph0 := -2*pd - tf*v0 + 3*tf*vf;
ph1 := -ad + jMax*tf;
ph2 := jMax*tf_tf*g1 - vd*ph0;
ph3 := 5*af_af + 2*jMax*(2*jMax*tf_tf - vd - 4*af*tf);
ph4 := jMax_jMax*tf_p4 - 2*vd_vd + 8*jMax*tf*(-pd + tf*vf);
ph5 := (5*af_p4 - 8*af_p3*jMax*tf - 12*af_af*jMax*(jMax*tf_tf + vd) + 24*af*jMax_jMax*(-2*pd + jMax*tf_p3 + 2*tf*vf) - 6*jMax_jMax*ph4);
ph6 := -vd_vd + jMax*tf*(-2*pd + 3*tf*v0 - tf*vf);
ph7 := 3*jMax_jMax*ph1*ph1;

polynom[0] := (4*af*tf - 2*jMax*tf_tf - 4*vd)/ph1;
polynom[1] := (-2*(a0_p4 + af_p4) + 8*af_p3*jMax*tf + 6*af_af*jMax_jMax*tf_tf + 8*a0_p3*(af - jMax*tf) - 12*a0_a0*(af - jMax*tf)*(af - jMax*tf) - 12*af*jMax_jMax*(-pd + jMax*tf_p3 - 2*tf*v0 + 3*tf*vf) + 2*a0*(4*af_p3 - 12*af_af*jMax*tf + 9*af*jMax_jMax*tf_tf - 3*jMax_jMax*(2*pd + jMax*tf_p3 - 2*tf*vf)) + 3*jMax_jMax*(jMax_jMax*tf_p4 + 4*vd_vd - 4*jMax*tf*(pd + tf*v0 - 2*tf*vf)))/ph7;
polynom[2] := (-a0_p5 + af_p5 - af_p4*jMax*tf + 5*a0_p4*(af - jMax*tf) - 2*a0_p3*ph3 - 4*af_p3*jMax*(jMax*tf_tf + vd) + 12*af_af*jMax_jMax*g2 - 12*af*jMax_jMax*ph6 + 2*a0_a0*(5*af_p3 - 9*af_af*jMax*tf - 6*af*jMax*vd + 6*jMax_jMax*ph0) + 12*jMax_jMax*jMax*ph2 + a0*(-5*af_p4 + 8*af_p3*jMax*tf + 12*af_af*jMax*(jMax*tf_tf + vd) - 24*af*jMax_jMax*(-2*pd + jMax*tf_p3 + 2*tf*vf) + 6*jMax_jMax*ph4))/(jMax*ph7);
polynom[3] := -(a0_p6 + af_p6 - 6*a0_p5*(af - jMax*tf) + 48*af_p3*jMax_jMax*g1 - 72*jMax_jMax*jMax*(jMax*g1*g1 + vd_vd*vd + 2*af*g1*vd) + 3*a0_p4*ph3 - 6*af_p4*jMax*vd + 36*af_af*jMax_jMax*vd_vd - 4*a0_p3*(5*af_p3 - 9*af_af*jMax*tf - 6*af*jMax*vd + 6*jMax_jMax*ph0) + 3*a0_a0*ph5 - 6*a0*(af_p5 - af_p4*jMax*tf - 4*af_p3*jMax*(jMax*tf_tf + vd) + 12*jMax_jMax*(af_af*g2 - af*ph6 + jMax*ph2)))/(6*jMax_jMax*ph7);

Roots.SolveQuartMonic(ADR(polynom), 4, rootCount:=d_extremasCount, roots:=d_extremas);
FOR i:=0 TO d_extremasCount
DO
  t := d_extremas[i];
  IF t > tf OR_ELSE t > (aMax - a0)/jMax
  THEN
    CONTINUE;
	END_IF

  h1 := ad_ad/(2*jMax_jMax) + (a0*(t + tf) - af*t + jMax*t*tf - vd)/jMax;
  IF h1 >= 0
  THEN
    h1 := SQRT(h1);
    
    Profile.t[0] := t;
    Profile.t[1] := tf - ad/jMax - 2*h1;
    Profile.t[2] := h1;
    Profile.t[3] := 0;
    Profile.t[4] := ad/jMax + h1 - t;
    Profile.t[5] := 0;
    Profile.t[6] := 0;
  
    time_none := Profile.CheckWithTiming(ProfileJerkSigns.Udud, ProfileLimits.None, tf, jMax, vMax, vMin, aMax, aMin);
    IF time_none
    THEN
      RETURN;
    END_IF
	END_IF
END_FOR


// 3 step Profile (ak. UZD), sometimes missed because of numerical errors T 012
h1 := -ad_ad + jMax*(2*(a0 + af)*tf - 4*vd + jMax*tf_tf);
IF h1 >= 0 AND_THEN (ABS(af - a0) < Constants.DoubleEpsilon) 
THEN
  h1 := SQRT(h1) / ABS(jMax);
  
  Profile.t[0] := (tf - h1 + ad/jMax)/2;
  Profile.t[1] := h1;
  Profile.t[2] := (tf - h1 - ad/jMax)/2;
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := 0;
  
  time_none := Profile.CheckWithTiming2(ProfileJerkSigns.Uddu, ProfileLimits.None, tf, jMax, vMax, vMin, aMax, aMin, jMax);
  IF time_none
  THEN
    RETURN;
	END_IF
ELSE 

  h1 := (3*(a0 + af)*tf - 2*vd)*(3*(a0 + af)*tf - 2*vd) + 24*ad*g2;
  h2 := -ad_ad + jf*(2*(a0 + af)*tf + jf*tf_tf - 4*vd);
  
  IF h1 >=0 AND_THEN h2 >= 0
  THEN
    h1 := ABS(jMax)/jMax*SQRT(h1);
    jf := (3*(a0_a0 - af_af)*tf + ad*(6*vd - h1))/(12*g2);  
    h2 := ABS(jMax)/jMax*SQRT(h2);
  
    Profile.t[0] := 0.5*(ad + h2)/(jf) + tf*0.5;
    Profile.t[1] := ad/jf + tf - 2*Profile.t[0];
    Profile.t[2] := tf - (Profile.t[0] + Profile.t[1]);
    Profile.t[3] := 0;
    Profile.t[4] := 0;
    Profile.t[5] := 0;
    Profile.t[6] := 0;
    
    time_none := Profile.CheckWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.None, tf, jMax, vMax, vMin, aMax, aMin);
    IF time_none
    THEN
      RETURN;
    END_IF
  END_IF
END_IF


// 3 step Profile (ak. UZU), sometimes missed because of numerical errors
polynom[0] := ad_ad;
polynom[1] := ad_ad*tf;
polynom[2] := (a0_a0 + af_af + 10*a0*af)*tf_tf + 24*(tf*(af*v0 - a0*vf) - pd*ad) + 12*vd_vd;
polynom[3] := -3*tf*((a0_a0 + af_af + 2*a0*af)*tf_tf - 4*vd*(a0 + af)*tf + 4*vd_vd);

Roots.SolveCub(ADR(polynom), rootCount:=d_extremasCount, roots:=d_extremas);
FOR i:=0 TO d_extremasCount
DO
  t := d_extremas[i];
  IF t <= 0.0 OR_ELSE ABS(t-tf) > Constants.DoubleEpsilon OR_ELSE ad = 0
  THEN
    CONTINUE;
  END_IF
  
  jf := ad/(tf - t);
  
  Profile.t[0] := (2*(vd - a0*tf) + ad*(t - tf))/(2*jf*t);
  Profile.t[1] := t;
  Profile.t[2] := 0;
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := tf - (Profile.t[0] + Profile.t[1]);
  
  time_none := Profile.CheckWithTiming2(ProfileJerkSigns.Uddu, ProfileLimits.None, tf, jMax, vMax, vMin, aMax, aMin, jMax);
  IF time_none
  THEN
    RETURN;
  END_IF 
END_FOR


// 3 step Profile (ak. UDU), sometimes missed because of numerical errors
Profile.t[0] := (ad_ad/jMax + 2*(a0 + af)*tf - jMax*tf_tf - 4*vd)/(4*(ad - jMax*tf));
Profile.t[1] := 0;
Profile.t[2] := -ad/(2*jMax) + tf * 0.5;
Profile.t[3] := 0;
Profile.t[4] := 0;
Profile.t[5] := 0;
Profile.t[6] := tf - (Profile.t[0] + Profile.t[2]);

time_none := Profile.CheckWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.None, tf, jMax, vMax, vMin, aMax, aMin);
IF time_none
THEN
  RETURN;
END_IF 

// 1 step Profile (ak. UDU), sometimes missed because of numerical errors
jf := ad/tf;
Profile.t[0] := tf;
Profile.t[1] := 0;
Profile.t[2] := 0;
Profile.t[3] := 0;
Profile.t[4] := 0;
Profile.t[5] := 0;
Profile.t[6] := 0;

time_none := Profile.CheckWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.None, tf, jf, vMax, vMin, aMax, aMin);
IF time_none
THEN
  RETURN;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_vel" Id="{36e16475-201b-495c-9333-d139efd29455}">
      <Declaration><![CDATA[METHOD PRIVATE time_vel : BOOL
VAR_IN_OUT
  Profile : ProfileDesc;
END_VAR
VAR_INPUT
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR
VAR
  p1, ph1, ph2, ph3, ph4, ph5, val_max : LREAL;
  polynom, deriv, dderiv, ddderiv, root : ARRAY[0..6] OF LREAL;
  dd_tz_intervals : ARRAY[0..6, 0..1] OF LREAL;
  rootCount, dd_tz_intervalCount : INT := -1;
  t, tz, tz_max, tz_current, dd_tz_current, tz_min : LREAL; 
  orig, deriv_newton, res, p_val, val_new : LREAL;
  h1 : LREAL;
  i : INT;  
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[tz_min := MAX(0.0, -a0/jMax);
tz_max := MIN((tf - a0/jMax)/2, (aMax - a0)/jMax);

IF (ABS(v0) < Constants.DoubleEpsilon AND_THEN ABS(a0) < Constants.DoubleEpsilon AND_THEN ABS(vf) < Constants.DoubleEpsilon AND_THEN ABS(af) < Constants.DoubleEpsilon)
THEN
  polynom[0] := 1;
  polynom[1] := -tf/2;
  polynom[2] := 0;
  polynom[3] := pd/(2*jMax);
  Roots.SolveCub(ADR(polynom), rootCount:=rootCount, roots:=root);

  FOR i:=0 TO rootCount
  DO
    t := root[i];
    IF (t > tf/4) THEN
      CONTINUE;
    END_IF
    
    // Single Newton step (regarding pd)
    IF t > Constants.DoubleEpsilon THEN
      orig := -pd + jMax*t*t*(tf - 2*t);
      ph2 := 2*jMax*t*(tf - 3*t);
      t := t - orig / ph2;
    END_IF
    
    profile.t[0] := t;
    profile.t[1] := 0;
    profile.t[2] := t;
    profile.t[3] := tf - 4*t;
    profile.t[4] := t;
    profile.t[5] := 0;
    profile.t[6] := t;
    
    time_vel := profile.CheckWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.Vel, tf, jMax, vMax, vMin, aMax, aMin);
    IF time_vel THEN
      RETURN;
    END_IF
  END_FOR      

ELSE
  
  // Profile UDDU
  p1 := af_af - 2*jMax*(-2*af*tf + jMax*tf_tf + 3*vd);
  ph1 := af_p3 - 3*jMax_jMax*g1 - 3*af*jMax*vd;
  ph2 := af_p4 + 8*af_p3*jMax*tf + 12*jMax*(3*jMax*vd_vd - af_af*vd + 2*af*jMax*(g1 - tf*vd) - 2*jMax_jMax*tf*g1);
  ph3 := a0*(af - jMax*tf);
  ph4 := jMax*(-ad + jMax*tf);
  
  // Find root of 5th order polynom
  polynom[0] := 1.0;
  polynom[1] := (15*a0_a0 + af_af + 4*af*jMax*tf - 16*ph3 - 2*jMax*(jMax*tf_tf + 3*vd))/(4*ph4);
  polynom[2] := (29*a0_p3 - 2*af_p3 - 33*a0*ph3 + 6*jMax_jMax*g1 + 6*af*jMax*vd + 6*a0*p1)/(6*jMax*ph4);
  polynom[3] := (61*a0_p4 - 76*a0_a0*ph3 - 16*a0*ph1 + 30*a0_a0*p1 + ph2)/(24*jMax_jMax*ph4);
  polynom[4] := (a0*(7*a0_p4 - 10*a0_a0*ph3 - 4*a0*ph1 + 6*a0_a0*p1 + ph2))/(12*jMax_jMax*jMax*ph4);
  polynom[5] := (7*a0_p6 + af_p6 - 12*a0_p4*ph3 + 48*af_p3*jMax_jMax*g1 - 8*a0_p3*ph1 - 72*jMax_jMax*jMax*(jMax*g1*g1 + vd_vd*vd + 2*af*g1*vd) - 6*af_p4*jMax*vd + 36*af_af*jMax_jMax*vd_vd + 9*a0_p4*p1 + 3*a0_a0*ph2)/(144*jMax_jMax*jMax_jMax*ph4);
  
  Roots.PolyMonicDeri(ADR(polynom), 5, out:=ADR(deriv));
  Roots.PolyDeri(ADR(deriv), 4, out:=ADR(dderiv));
  
  // Solve 4th order derivative analytically
  Roots.SolveQuartMonic(ADR(deriv[1]), 4, rootCount:=d_extremasCount, roots:=d_extremas);
  
  tz_current := tz_min;
  BubbleSortLreal(data:=ADR(d_extremas), d_extremasCount, indicesSorted:=ADR(indices));
  FOR i:=0 TO d_extremasCount
  DO
    tz := d_extremas[indices[i]];
    IF tz >= tz_max
    THEN
      CONTINUE;
    END_IF
  
    orig := Roots.PolyEval(ADR(deriv), 4, tz);
    IF (ABS(orig) > Constants.Tolerance) THEN
      tz := tz - orig / Roots.PolyEval(ADR(dderiv), 3, tz);
    END_IF
    
    val_new := Roots.PolyEval(ADR(polynom), 5, tz);
    IF (ABS(val_new) < 64 * ABS(Roots.PolyEval(ADR(dderiv), 3, tz)) * Constants.Tolerance)
    THEN
      root[rootCount+1] := tz;
      rootCount := rootCount + 1;
    ELSIF (Roots.PolyEval(ADR(polynom), 5, tz_current) * val_new < 0)
    THEN
      root[rootCount+1] := Roots.ShrinkInterval(ADR(polynom), 5, tz_current, tz);
      rootCount := rootCount + 1;
    END_IF
    
    tz_current := tz;
  END_FOR
  
  val_max := Roots.PolyEval(ADR(polynom), 5, tz_max);
  IF Roots.PolyEval(ADR(polynom), 5, tz_current) * val_max < 0
  THEN
    root[rootCount+1] := Roots.ShrinkInterval(ADR(polynom), 5, tz_current, tz_max);
    rootCount := rootCount + 1;
  ELSIF ABS(val_max) < 8 * Constants.DoubleEpsilon
  THEN
    root[rootCount+1] := tz_max;
    rootCount := rootCount + 1;
  END_IF

  FOR i:=0 TO rootCount
  DO
    t := root[i];
    IF t < 0.0
    THEN
      CONTINUE;
    END_IF
    
    h1 := (a0_a0 + af_af)*0.5 + jMax*(2*a0*t + jMax*t*t - vd);
    IF h1 < 0
    THEN
      CONTINUE;
    END_IF
    
    h1 := SQRT(h1)/ABS(jMax);
    orig := -pd - (2*a0_p3 + 4*af_p3 + 24*a0*jMax*t*(af + jMax*(h1 + t - tf)) + 6*a0_a0*(af + jMax*(2*t - tf)) + 6*(a0_a0 + af_af)*jMax*h1 + 12*af*jMax*(jMax*t*t - vd) + 12*jMax_jMax*(jMax*t*t*(h1 + t - tf) - tf*v0 - h1*vd))/(12*jMax_jMax);
    deriv_newton := -(a0 + jMax*t)*(3*(h1 + t) - 2*tf + (a0 + 2*af)/jMax);
    
    IF ABS(deriv_newton) < Constants.DoubleEpsilon
    THEN
      CONTINUE;
    END_IF
    
    t := t - orig / deriv_newton;
  
    IF t > tf OR_ELSE t <> t (*isnan*)
    THEN
      CONTINUE;
    END_IF
  
    h1 := (a0_a0 + af_af)/(2*jMax_jMax) + (t*(2*a0 + jMax*t) - vd)/jMax;
    IF h1 >= 0
    THEN
      h1 := SQRT(h1);
    
      Profile.t[0] := t;
      Profile.t[1] := 0;
      Profile.t[2] := t + a0/jMax;
      Profile.t[3] := tf - 2*(t + h1) - (a0 + af)/jMax;
      Profile.t[4] := h1;
      Profile.t[5] := 0;
      Profile.t[6] := h1 + af/jMax;
    
      time_vel := Profile.CheckWithTiming(ProfileJerkSigns.Uddu, ProfileLimits.vel, tf, jMax, vMax, vMin, aMax, aMin);
      IF time_vel
      THEN
        RETURN;
      END_IF
    END_IF
  END_FOR
  
  // Profile UDUD
  ph1 := af_af - 2*jMax*(2*af*tf + jMax*tf_tf - 3*vd);
  ph2 := af_p3 - 3*jMax_jMax*g1 + 3*af*jMax*vd;
  ph3 := 2*jMax*tf*g1 + 3*vd_vd;
  ph4 := af_p4 - 8*af_p3*jMax*tf + 12*jMax*(jMax*ph3 + af_af*vd + 2*af*jMax*(g1 - tf*vd));
  ph5 := af + jMax*tf;
  
  // Find root of 6th order polynom
  polynom[0] := 1.0;
  polynom[1] := (5*a0 - ph5)/jMax;
  polynom[2] := (39*a0_a0 - ph1 - 16*a0*ph5)/(4*jMax_jMax);
  polynom[3] := (55*a0_p3 - 33*a0_a0*ph5 - 6*a0*ph1 + 2*ph2)/(6*jMax_jMax*jMax);
  polynom[4] := (101*a0_p4 + ph4 - 76*a0_p3*ph5 - 30*a0_a0*ph1 + 16*a0*ph2)/(24*jMax_jMax*jMax_jMax);
  polynom[5] := (a0*(11*a0_p4 + ph4 - 10*a0_p3*ph5 - 6*a0_a0*ph1 + 4*a0*ph2))/(12*jMax_jMax*jMax_jMax*jMax);
  polynom[6] := (11*a0_p6 - af_p6 - 12*a0_p5*ph5 - 48*af_p3*jMax_jMax*g1 - 9*a0_p4*ph1 + 72*jMax_jMax*jMax*(jMax*g1*g1 - vd_vd*vd - 2*af*g1*vd) - 6*af_p4*jMax*vd - 36*af_af*jMax_jMax*vd_vd + 8*a0_p3*ph2 + 3*a0_a0*ph4)/(144*jMax_jMax*jMax_jMax*jMax_jMax);
  
  Roots.PolyMonicDeri(ADR(polynom), 6, out:=ADR(deriv));
  Roots.PolyMonicDeri(ADR(deriv), 5, out:=ADR(dderiv));
  Roots.SolveQuartMonic(ADR(dderiv[1]), 4, rootCount:=rootCount, roots:=root);
  
  tz_min := 0.0;
  tz_max := tf;
  dd_tz_current := tz_min;
  
  FOR i:=0 TO rootCount
  DO
    tz := root[i];
    IF tz >= tz_max
    THEN
      CONTINUE;
    END_IF
    
    orig := Roots.PolyEval(ADR(dderiv), 4, tz);
    IF (ABS(orig) > Constants.Tolerance)
    THEN
      Roots.PolyMonicDeri(ADR(dderiv), 4, out:=ADR(ddderiv));   
      tz := tz - Roots.PolyEval(ADR(dderiv), 4, tz) / Roots.PolyEval(ADR(ddderiv), 3, tz);
    END_IF  
  
    IF (Roots.PolyEval(ADR(deriv), 5, dd_tz_current) * Roots.PolyEval(ADR(deriv), 5, tz) < 0)
    THEN
      dd_tz_intervals[dd_tz_intervalCount+1, 0] := dd_tz_current;
      dd_tz_intervals[dd_tz_intervalCount+1, 1] := tz;
      dd_tz_intervalCount := dd_tz_intervalCount + 1;
    END_IF
  
    dd_tz_current := tz;
      
  END_FOR
  
  IF (Roots.PolyEval(ADR(deriv), 5, dd_tz_current) * Roots.PolyEval(ADR(deriv), 5, tz_max) < 0)
  THEN
    dd_tz_intervals[dd_tz_intervalCount+1, 0] := dd_tz_current; 
    dd_tz_intervals[dd_tz_intervalCount+1, 1] := tz_max;
    dd_tz_intervalCount := dd_tz_intervalCount + 1;
  END_IF
  
  rootCount := -1;
  tz_current := tz_min;
  FOR i:=0 TO dd_tz_intervalCount
  DO
    tz := Roots.ShrinkInterval(ADR(deriv), 5, dd_tz_intervals[i, 0], dd_tz_intervals[i, 1]);
    IF tz >= tz_max
    THEN
      CONTINUE;
    END_IF
    
    p_val := Roots.PolyEval(ADR(polynom), 6, tz);
    IF (ABS(p_val) < 64 * ABS(Roots.PolyEval(ADR(dderiv), 4, tz)) * Constants.Tolerance)
    THEN
      root[rootCount+1] := tz;
      rootCount := rootCount + 1;
    ELSIF (Roots.PolyEval(ADR(polynom), 6, tz_current) * p_val < 0)
    THEN
      root[rootCount+1] := Roots.ShrinkInterval(ADR(polynom), 6, tz_current, tz);
      rootCount := rootCount + 1;
    END_IF
    tz_current := tz;
  END_FOR
  
  IF (Roots.PolyEval(ADR(polynom), 6, tz_current) * Roots.PolyEval(ADR(polynom), 6, tz_max) < 0)
  THEN
    root[rootCount+1] := Roots.ShrinkInterval(ADR(polynom), 6, tz_current, tz_max);
    rootCount := rootCount + 1;
  END_IF
  
  
  FOR i:=0 TO rootCount
  DO
    t := root[i];
    
    // Double Newton step (regarding pd)
    h1 := (af_af - a0_a0)/(2*jMax_jMax) - ((2*a0 + jMax*t)*t - vd)/jMax;
    IF h1 < 0
    THEN
      CONTINUE;
    END_IF
    
    h1 := SQRT(h1);
    orig := -pd + (af_p3 - a0_p3 + 3*a0_a0*jMax*(tf - 2*t))/(6*jMax_jMax) + (2*a0 + jMax*t)*t*(tf - t) + (jMax*h1 - af)*h1*h1 + tf*v0;
    deriv_newton := (a0 + jMax*t)*(2*(af + jMax*tf) - 3*jMax*(h1 + t) - a0)/jMax;
  
    IF ABS(deriv_newton) <= Constants.DoubleEpsilon
    THEN
      CONTINUE;
    END_IF
    
    t := t - orig / deriv_newton;
    h1 := (af_af - a0_a0)*0.5 - jMax*((2*a0 + jMax*t)*t - vd);
    IF h1 < 0
    THEN
      CONTINUE;
    END_IF
    h1 := SQRT(h1)/ABS(jMax);  
    orig := -pd + (af_p3 - a0_p3 + 3*a0_a0*jMax*(tf - 2*t))/(6*jMax_jMax) + (2*a0 + jMax*t)*t*(tf - t) + (jMax*h1 - af)*h1*h1 + tf*v0;
    IF (ABS(orig) > 1E-9)
    THEN
      deriv_newton := (a0 + jMax*t)*(2*(af + jMax*tf) - 3*jMax*(h1 + t) - a0)/jMax;
      
      IF ABS(deriv_newton) <= Constants.DoubleEpsilon
      THEN
        CONTINUE;
      END_IF
      
      t := t - orig / deriv_newton;           
    END_IF
  
    h1 := (af_af - a0_a0)*0.5 - jMax*((2*a0 + jMax*t)*t - vd);
    IF h1 < 0
    THEN
      CONTINUE;
    END_IF
    h1 := SQRT(h1)/ABS(jMax);
    Profile.t[0] := t;
    Profile.t[1] := 0;
    Profile.t[2] := t + a0/jMax;
    Profile.t[3] := tf - 2*(t + h1) + ad/jMax;
    Profile.t[4] := h1;
    Profile.t[5] := 0;
    Profile.t[6] := h1 - af/jMax;
  
    time_vel := Profile.CheckWithTiming(ProfileJerkSigns.Udud, ProfileLimits.Vel, tf, jMax, vMax, vMin, aMax, aMin);
    IF time_vel
    THEN
      RETURN;
    END_IF
  END_FOR
END_IF]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>