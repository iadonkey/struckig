<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="PositionStep1" Id="{59242074-56b3-4cce-98f4-96108527bef2}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK INTERNAL PositionStep1
VAR
  p0, v0, a0 : LREAL;
  pf, vf, af : LREAL;
  _vMax, _vMin, _aMax, _aMin, _jMax : LREAL;

  // Pre-calculated expressions
  pd : LREAL;
  v0_v0, vf_vf : LREAL;
  a0_a0, a0_p3, a0_p4 : LREAL;
  af_af, af_p3, af_p4 : LREAL;
  jMax_jMax : LREAL;
  
  // runtime  calculated expressions
  polynom : ARRAY[0..4] OF LREAL;
  orig : LREAL;
  deriv : LREAL;
  t : LREAL;
  i : INT;
  h0, h1, h2, h2_h2, h3, h5 : LREAL;
  t_min, t_max : LREAL;
  t_acc1, t_acc0 : LREAL;
  validProfiles : ARRAY[0..5] OF ProfileDesc; // Max 5 valid profiles + 1 spare for numerical issues
  validProfileCounter : INT := -1;
  
  rootCount : INT;
  root : ARRAY[0..6] OF LREAL;
  left_duration, right_duration : LREAL;   
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="AddInterval" Id="{f04cf183-f22e-4a08-854f-8d9fd235e3cd}">
      <Declaration><![CDATA[METHOD AddInterval
VAR_INPUT
  interval : REFERENCE TO BlockInterval;
  Left : REFERENCE TO ProfileDesc;
  Right : REFERENCE TO ProfileDesc;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[left_duration := Left.t_sum[6] + Left.Brake.Duration;
right_duration := Right.t_sum[6] + Right.Brake.Duration;
IF (left_duration < right_duration)
THEN
  interval.Left := left_duration;
  interval.Right := right_duration;
  interval.Profile := Right;
  interval.IsUsed := TRUE;
ELSE
  interval.Left := right_duration;
  interval.Right := left_duration;
  interval.Profile := Left;
  interval.IsUsed := TRUE;  
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddProfile" Id="{443ac9a1-c2c8-4422-873c-d80f090e8e87}">
      <Declaration><![CDATA[METHOD AddProfile
VAR_IN_OUT CONSTANT
  Profile : ProfileDesc;
  jMax : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[validProfileCounter := validProfileCounter + 1;
validProfiles[validProfileCounter] := Profile;
validProfiles[validProfileCounter].Direction := SEL(jMax > 0, ProfileDirection.Down, ProfileDirection.Up);]]></ST>
      </Implementation>
    </Method>
    <Method Name="CalculateBlock" Id="{50e177a8-dca6-48ec-aabe-f9c22fb4f02a}">
      <Declaration><![CDATA[METHOD CalculateBlock : BOOL
VAR_INPUT
  block : REFERENCE TO Block;
END_VAR
VAR
  i, j : INT;
  Tmin : LREAL;
  idx_min : INT;
  idx_else_1, idx_else_2, idx_else_3, idx_else_4 : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF validProfileCounter = 0
THEN
  block.Pmin := validProfiles[0];
  block.Tmin := block.Pmin.t_sum[6] + block.Pmin.Brake.Duration;  
  CalculateBlock := TRUE;

ELSIF validProfileCounter = 1 
THEN

  IF ABS(validProfiles[0].t_sum[6] - validProfiles[1].t_sum[6]) < 8*Constants.Epsilon
  THEN
    block.Pmin := validProfiles[0];
    block.Tmin := block.Pmin.t_sum[6] + block.Pmin.Brake.Duration;  
    CalculateBlock := TRUE;
    RETURN;
	END_IF
  
  IF ParameterList.NumericalRobust
  THEN
    idx_min := SEL(validProfiles[0].t_sum[6] < validProfiles[1].t_sum[6], 1, 0);
    idx_else_1 := (idx_min + 1) MOD 2;

    block.Pmin := validProfiles[idx_min];
    block.Tmin := block.Pmin.t_sum[6] + block.Pmin.Brake.Duration;
    
    AddInterval(block.A, validProfiles[idx_min], validProfiles[idx_else_1]);
    CalculateBlock := TRUE;
    RETURN; 
	END_IF

// Only happens due to numerical issues
ELSIF (validProfileCounter = 3) 
THEN
  // Find "identical" profiles
  IF (ABS(validProfiles[0].t_sum[6] - validProfiles[1].t_sum[6]) < 32*Constants.Epsilon AND_THEN validProfiles[0].Direction <> validProfiles[1].Direction)
  THEN
    RemoveProfile(1);
  ELSIF (ABS(validProfiles[2].t_sum[6] - validProfiles[3].t_sum[6]) < 256*Constants.Epsilon  AND_THEN validProfiles[2].Direction <> validProfiles[3].Direction)
  THEN
    RemoveProfile(3);
  ELSIF (ABS(validProfiles[0].t_sum[6] - validProfiles[3].t_sum[6]) < 256*Constants.Epsilon AND_THEN validProfiles[0].Direction <> validProfiles[3].Direction)
  THEN
    RemoveProfile(3);
  ELSE
    RETURN;
  END_IF

ELSIF ((validProfileCounter+1) MOD 2 = 0)
THEN
  RETURN;
END_IF

// Find index of fastest Profile
Tmin := Constants.Infinity;
FOR i:=0 TO validProfileCounter
DO
  FOR j:=0 TO validProfileCounter
  DO
    IF validProfiles[i].t_sum[6] + validProfiles[i].brake.Duration < validProfiles[j].t_sum[6] + validProfiles[j].brake.Duration AND_THEN
       validProfiles[i].t_sum[6] + validProfiles[i].brake.Duration < Tmin
    THEN
      Tmin := validProfiles[i].t_sum[6] + validProfiles[i].brake.Duration;
      idx_min := i;
		END_IF
  END_FOR
END_FOR

block.A.IsUsed := FALSE;
block.B.IsUsed := FALSE;
block.Pmin := validProfiles[idx_min];
block.Tmin := block.Pmin.t_sum[6] + block.Pmin.Brake.Duration;  

IF (validProfileCounter = 2)
THEN
  idx_else_1 := (idx_min + 1) MOD 3;
  idx_else_2 := (idx_min + 2) MOD 3;
  
  AddInterval(block.A, validProfiles[idx_else_1], validProfiles[idx_else_2]);
  CalculateBlock := TRUE;
  RETURN;

 ELSIF (validProfileCounter = 4)
 THEN
  idx_else_1 := (idx_min + 1) MOD 5;
  idx_else_2 := (idx_min + 2) MOD 5;
  idx_else_3 := (idx_min + 3) MOD 5;
  idx_else_4 := (idx_min + 4) MOD 5;
  
  IF (validProfiles[idx_else_1].Direction = validProfiles[idx_else_2].Direction)
  THEN
    AddInterval(block.A, validProfiles[idx_else_1], validProfiles[idx_else_2]);
    AddInterval(block.B, validProfiles[idx_else_3], validProfiles[idx_else_4]);
  ELSE 
    AddInterval(block.A, validProfiles[idx_else_1], validProfiles[idx_else_4]);
    AddInterval(block.B, validProfiles[idx_else_2], validProfiles[idx_else_3]);
  END_IF
  
  CalculateBlock := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Get" Id="{1c1bdad0-f955-4d7e-82c0-f0b69b7c5251}">
      <Declaration><![CDATA[METHOD Get : BOOL
VAR_INPUT
  Profilefile : REFERENCE TO ProfileDesc;
  block : REFERENCE TO Block; 
END_VAR
VAR_INST
  vMax, vMin, aMax, aMin, jMax : LREAL;  
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Profilefile.SetBoundaryPosition(p0, v0, a0, pf, vf, af);
validProfileCounter := -1;

IF (ABS(vf) < Constants.DoubleEpsilon AND_THEN ABS(af) < Constants.DoubleEpsilon) THEN
  vMax := SEL(pd >= 0, _vMin, _vMax);
  vMin := SEL(pd >= 0, _vMax, _vMin);
  aMax := SEL(pd >= 0, _aMin, _aMax);
  aMin := SEL(pd >= 0, _aMax, _aMin);
  jMax :=SEL (pd >= 0,-_jMax, _jMax);

  IF ABS(v0) < Constants.DoubleEpsilon AND_THEN ABS(a0) < Constants.DoubleEpsilon AND_THEN ABS(pd) < Constants.DoubleEpsilon
  THEN
    time_none(Profilefile, vMax, vMin, aMax, aMin, jMax);
  ELSE
    // There is no blocked interval when vf==0 && af==0, so return after first found profile
    time_all_vel(Profilefile, vMax, vMin, aMax, aMin, jMax);
    IF (validProfileCounter > 0) THEN
      Get := CalculateBlock(block);
      RETURN;
    END_IF
    time_none(Profilefile, vMax, vMin, aMax, aMin, jMax);
    IF (validProfileCounter > 0) THEN
      Get := CalculateBlock(block);
      RETURN;
    END_IF
    time_acc0(Profilefile, vMax, vMin, aMax, aMin, jMax);
    IF (validProfileCounter > 0) THEN
      Get := CalculateBlock(block);
      RETURN;
    END_IF
    time_acc1(Profilefile, vMax, vMin, aMax, aMin, jMax);
    IF (validProfileCounter > 0) THEN
      Get := CalculateBlock(block);
      RETURN;
    END_IF
    time_acc0_acc1(Profilefile, vMax, vMin, aMax, aMin, jMax);
    IF (validProfileCounter > 0) THEN
      Get := CalculateBlock(block);
      RETURN;
    END_IF
    time_all_vel(Profilefile, vMax, vMin, aMax, aMin, jMax);
    IF (validProfileCounter > 0) THEN
      Get := CalculateBlock(block);
      RETURN;
    END_IF
    time_none(Profilefile, vMin, vMax, aMin, aMax, -jMax);
    IF (validProfileCounter > 0) THEN
      Get := CalculateBlock(block);
      RETURN;
    END_IF
    time_acc0(Profilefile, vMin, vMax, aMin, aMax, -jMax);
    IF (validProfileCounter > 0) THEN
      Get := CalculateBlock(block);
      RETURN;
    END_IF
    time_acc1(Profilefile, vMin, vMax, aMin, aMax, -jMax);
    IF (validProfileCounter > 0) THEN
      Get := CalculateBlock(block);
      RETURN;
    END_IF
    time_acc0_acc1(Profilefile, vMin, vMax, aMin, aMax, -jMax);          
  END_IF
ELSE 
  time_all_vel(Profilefile, _vMax, _vMin, _aMax, _aMin, _jMax);
  time_all_vel(Profilefile, _vMin, _vMax, _aMin, _aMax, -_jMax);
  time_none(Profilefile, _vMax, _vMin, _aMax, _aMin, _jMax);
  time_acc0(Profilefile, _vMax, _vMin, _aMax, _aMin, _jMax);
  time_acc1(Profilefile, _vMax, _vMin, _aMax, _aMin, _jMax);
  time_acc0_acc1(Profilefile, _vMax, _vMin, _aMax, _aMin, _jMax);
  time_none(Profilefile, _vMin, _vMax, _aMin, _aMax, -_jMax);
  time_acc0(Profilefile, _vMin, _vMax, _aMin, _aMax, -_jMax);
  time_acc1(Profilefile, _vMin, _vMax, _aMin, _aMax, -_jMax);
  time_acc0_acc1(Profilefile, _vMin, _vMax, _aMin, _aMax, -_jMax);  
END_IF

IF (validProfileCounter = -1)
THEN
  time_none_two_step(Profilefile, _vMax, _vMin, _aMax, _aMin, _jMax);
  IF validProfileCounter >= 0
  THEN
    Get := CalculateBlock(block);
    RETURN;
	END_IF
  
  time_none_two_step(Profilefile, _vMin, _vMax, _aMin, _aMax, -_jMax);
  IF validProfileCounter >= 0
  THEN
    Get := CalculateBlock(block);
    RETURN;
	END_IF
  

  time_acc0_two_step(Profilefile, _vMax, _vMin, _aMax, _aMin, _jMax);
  IF validProfileCounter >= 0
  THEN
    Get := CalculateBlock(block);
    RETURN;
	END_IF
  
  time_acc0_two_step(Profilefile, _vMin, _vMax, _aMin, _aMax, -_jMax);
  IF validProfileCounter >= 0
  THEN
    Get := CalculateBlock(block);
    RETURN;
	END_IF
  
  time_vel_two_step(Profilefile, _vMax, _vMin, _aMax, _aMin, _jMax);
  IF validProfileCounter >= 0
  THEN
    Get := CalculateBlock(block);
    RETURN;
	END_IF
  
  time_vel_two_step(Profilefile, _vMin, _vMax, _aMin, _aMax, -_jMax);
  IF validProfileCounter >= 0
  THEN
    Get := CalculateBlock(block);
    RETURN;
	END_IF
  
  time_acc1_vel_two_step(Profilefile, _vMax, _vMin, _aMax, _aMin, _jMax);
  IF validProfileCounter >= 0
  THEN
    Get := CalculateBlock(block);
    RETURN;
	END_IF
  
  time_acc1_vel_two_step(Profilefile, _vMin, _vMax, _aMin, _aMax, -_jMax);
  IF validProfileCounter >= 0
  THEN
    Get := CalculateBlock(block);
    RETURN;
	END_IF  
END_IF

Get := CalculateBlock(block);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="RemoveProfile" Id="{bd3a75f9-6643-430d-baa6-3b74a1498442}">
      <Declaration><![CDATA[METHOD PRIVATE RemoveProfile : BOOL
VAR_INPUT
  index : INT;
END_VAR
VAR
  i : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// todo, this is pretty slow in twincat
FOR i:=index TO validProfileCounter-2
DO
  validProfiles[i] := validProfiles[i + 1];
END_FOR

validProfileCounter := validProfileCounter - 1;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Set" Id="{ce744db4-d360-45a6-a3e4-2c7d816397cb}">
      <Declaration><![CDATA[METHOD Set
VAR_INPUT
  p0, v0, a0 : LREAL;
  pf, vf, af : LREAL;
  vMax, vMin : LREAL;
  aMax, aMin : LREAL;
  jMax : LREAL;  
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.p0 := p0;
THIS^.v0 := v0;
THIS^.a0 := a0;
THIS^.pf := pf;
THIS^.vf := vf;
THIS^.af := af;
_vMax := vMax;
_vMin := vMin;
_aMax := aMax;
_aMin := aMin;
_jMax := jMax;

pd := pf - p0;

v0_v0 := v0 * v0;
vf_vf := vf * vf;

a0_a0 := a0 * a0;
af_af := af * af;

a0_p3 := a0 * a0_a0;
a0_p4 := a0_a0 * a0_a0;
af_p3 := af * af_af;
af_p4 := af_af * af_af;

// max values needs to be invariant to plus minus sign change
jMax_jMax := jMax * jMax;]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc0" Id="{5ee3df37-2f62-4540-8c35-85e55810ddc3}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc0
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[h3 := (a0_a0 - af_af)/(2*aMax*jMax) + (vf - v0)/aMax;
t_max := (aMax - aMin)/jMax;

h0 := 3*(af_p4 - a0_p4) + 8*(a0_p3 - af_p3)*aMax + 24*aMax*jMax*(af*vf - a0*v0) - 6*a0_a0*(aMax*aMax - 2*jMax*v0) + 6*af_af*(aMax*aMax - 2*jMax*vf) + 12*jMax*(jMax*(vf_vf - v0_v0 - 2*aMax*pd) - aMax*aMax*(vf - v0));
h2 := -af_af + aMax*aMax + 2*jMax*vf;
    
polynom[0] := (-2*aMax)/jMax;
polynom[1] := h2/jMax_jMax;
polynom[2] := 0;
polynom[3] := h0/(12*jMax_jMax*jMax_jMax);

t_min := (aMax - af)/jMax;
    
Roots.SolveQuartMonic(ADR(polynom), 4, rootCount:=rootCount, roots:=root);
FOR i:=0 TO rootCount
DO
  t := root[i];
  IF t < t_min OR_ELSE t > t_max
  THEN
    CONTINUE;
  END_IF
  
  // Single Newton step (regarding pd)
  IF t > Constants.DoubleEpsilon
  THEN
    h1 := jMax*t;
    orig := h0/(24*aMax*jMax_jMax) + t*t*(h2 + h1*(h1 - 2*aMax))/(2*aMax);
    deriv := t*(h2 + h1*(2*h1 - 3*aMax))/aMax;
    IF ABS(deriv) > Constants.DoubleEpsilon
    THEN
      t := t - orig / deriv;
    END_IF
  END_IF
  
  IF ABS(deriv) < Constants.DoubleEpsilon
  THEN
    CONTINUE;
	END_IF
  
  Profile.t[0] := (-a0 + aMax)/jMax;
  Profile.t[1] := h3 - 2*t + jMax/aMax*t*t;
  Profile.t[2] := t;
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := (af - aMax)/jMax + t;
  
  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc0, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN
    AddProfile(Profile, jMax);        
  END_IF
END_FOR   ]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc0_acc1" Id="{e5212c06-396a-492c-bc44-27957c4ab5ed}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc0_acc1
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR
VAR
  temp : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[h1 := (3*(af_p4*aMax - a0_p4*aMin) + aMax*aMin*(8*(a0_p3 - af_p3) + 3*aMax*aMin*(aMax - aMin) + 6*aMin*af_af - 6*aMax*a0_a0) + 12*jMax*(aMax*aMin*((aMax - 2*a0)*v0 - (aMin - 2*af)*vf) + aMin*a0_a0*v0 - aMax*af_af*vf))/(3*(aMax - aMin)*jMax_jMax) + 4*(aMax*vf_vf - aMin*v0_v0 - 2*aMin*aMax*pd)/(aMax - aMin);
IF (h1 >= 0) // check if h1 isNan
THEN
  h1 := SQRT(h1) * 0.5;
  h2 := a0_a0/(2*aMax*jMax) + (aMin - 2*aMax)/(2*jMax) - v0/aMax;
  h3 := -af_af/(2*aMin*jMax) - (aMax - 2*aMin)/(2*jMax) + vf/aMin;
  
  // UDDU: Solution 2
  IF h2 > h1/aMax AND_THEN h3 > -h1/aMin
  THEN
    profile.t[0] := (-a0 + aMax)/jMax;
    profile.t[1] := h2 - h1/aMax;
    profile.t[2] := aMax/jMax;
    profile.t[3] := 0;
    profile.t[4] := -aMin/jMax;
    profile.t[5] := h3 + h1/aMin;
    profile.t[6] := profile.t[4] + af/jMax;
  
    IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc0Acc1, jMax, vMax, vMin, aMax, aMin, setLimits:=TRUE))
    THEN
      AddProfile(Profile, jMax);            
    END_IF
  END_IF
  
  // UDDU: Solution 1  
  IF h2 > -h1/aMax AND_THEN h3 > h1/aMin
  THEN
    Profile.t[0] := (-a0 + aMax)/jMax;
    Profile.t[1] := h2 + h1/aMax;
    Profile.t[2] := aMax/jMax;
    Profile.t[3] := 0;
    Profile.t[4] := -aMin/jMax;
    Profile.t[5] := h3 - h1/aMin;
    Profile.t[6] := Profile.t[4] + af/jMax;
  
    IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc0Acc1, jMax, vMax, vMin, aMax, aMin, setLimits:=TRUE))
    THEN
      AddProfile(Profile, jMax);              
    END_IF
	END_IF  
END_IF




]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc0_two_step" Id="{bb72dd1e-fc6d-4110-a222-a9ef280818c2}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc0_two_step
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ABS(2*a0*jMax) > Constants.Epsilon
THEN
  // Two step
  Profile.t[0] := 0;
  Profile.t[1] := (af_af - a0_a0 + 2*jMax*(vf - v0))/(2*a0*jMax);
  Profile.t[2] := (a0 - af)/jMax;
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := 0;
  
  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc0, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN
    AddProfile(Profile, jMax);
    RETURN;
  END_IF
END_IF

// Three step - Removed pf
Profile.t[0] := (-a0 + aMax)/jMax;
Profile.t[1] := (a0_a0 + af_af - 2*aMax*aMax + 2*jMax*(vf - v0))/(2*aMax*jMax);
Profile.t[2] := (-af + aMax)/jMax;
Profile.t[3] := 0;
Profile.t[4] := 0;
Profile.t[5] := 0;
Profile.t[6] := 0;

IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc0, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
THEN
  AddProfile(Profile, jMax);
  RETURN;     
END_IF


// Three step - Removed aMax
h0 := 3*(af_af - a0_a0 + 2*jMax*(v0 + vf));
h2 := a0_p3 + 2*af_p3 + 6*jMax_jMax*pd + 6*(af - a0)*jMax*vf - 3*a0*af_af;
h1 := 2*(2*h2*h2 + h0*(a0_p4 - 6*a0_a0*(af_af + 2*jMax*vf) + 8*a0*(af_p3 + 3*jMax_jMax*pd + 3*af*jMax*vf) - 3*(af_p4 + 4*af_af*jMax*vf + 4*jMax_jMax*(vf_vf - v0_v0))));
IF h1 >= 0 AND_THEN ABS(h0) > Constants.DoubleEpsilon
THEN
  h1 := SQRT(h1) * ABS(jMax) / jMax;
  
  Profile.t[0] := (4*af_p3 + 2*a0_p3 - 6*a0*af_af + 12*jMax_jMax*pd + 12*(af - a0)*jMax*vf + h1)/(2*jMax*h0);
  Profile.t[1] := -h1/(jMax*h0);
  Profile.t[2] := (-4*a0_p3 - 2*af_p3 + 6*a0_a0*af + 12*jMax_jMax*pd - 12*(af - a0)*jMax*v0 + h1)/(2*jMax*h0);
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := 0;
  
  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc0, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN
    AddProfile(Profile, jMax);
    RETURN;     
  END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc1" Id="{6fa9f1fb-2a10-4190-9e2d-428719e15794}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc1
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[h3 := -(a0_a0 + af_af)/(2*jMax*aMin) + aMin/jMax + (vf - v0)/aMin;
t_max := (-a0 + aMax)/jMax;

h0 := (a0_p4 - af_p4)/4 + 2*(af_p3 - a0_p3)*aMin/3 + (a0_a0 - af_af)*aMin*aMin/2 + jMax*(af_af*vf + a0_a0*v0 + 2*aMin*(jMax*pd - a0*v0 - af*vf) + aMin*aMin*(v0 + vf) + jMax*(v0_v0 - vf_vf));
h2 := a0_a0 - a0*aMin + 2*jMax*v0;

polynom[0] := (2*(2*a0 - aMin))/jMax;
polynom[1] := (5*a0_a0 + aMin*(aMin - 6*a0) + 2*jMax*v0)/jMax_jMax;
polynom[2] := 2*(a0 - aMin)*h2/(jMax_jMax*jMax);
polynom[3] := h0/(jMax_jMax*jMax_jMax);

t_min := -(a0 - aMin)/jMax;
    
Roots.SolveQuartMonic(ADR(polynom), 4, rootCount:=rootCount, roots:=root);
FOR i:=0 TO rootCount
DO
  t := root[i];
  IF (t < t_min OR_ELSE t > t_max) THEN
    CONTINUE;
  END_IF 

  IF t > Constants.DoubleEpsilon
  THEN
    // Double Newton step (regarding pd)
    h5 := a0_p3 + 2*jMax*a0*v0;
    h1 := jMax*t;
    orig := -(h0/2 + h1*(h5 + a0*(aMin - 2*h1)*(aMin - h1) + a0_a0*(5*h1/2 - 2*aMin) + aMin*aMin*h1/2 + jMax*(h1/2 - aMin)*(h1*t + 2*v0)))/(aMin*jMax_jMax);
    deriv := (aMin - a0 - h1)*(h2 + h1*(4*a0 - aMin + 2*h1))/(aMin*jMax);  
    IF ABS(deriv) > Constants.DoubleEpsilon
    THEN
      t := t - MIN(orig / deriv, t);
      
      h1 := jMax*t;
      orig := -(h0/2 + h1*(h5 + a0*(aMin - 2*h1)*(aMin - h1) + a0_a0*(5*h1/2 - 2*aMin) + aMin*aMin*h1/2 + jMax*(h1/2 - aMin)*(h1*t + 2*v0)))/(aMin*jMax_jMax);
      IF (ABS(orig) > 1E-9)
      THEN
        deriv := (aMin - a0 - h1)*(h2 + h1*(4*a0 - aMin + 2*h1))/(aMin*jMax);
        
        IF ABS(deriv) > Constants.DoubleEpsilon
        THEN
          t := t - orig / deriv; 
          h1 := jMax*t;
          orig := -(h0/2 + h1*(h5 + a0*(aMin - 2*h1)*(aMin - h1) + a0_a0*(5*h1/2 - 2*aMin) + aMin*aMin*h1/2 + jMax*(h1/2 - aMin)*(h1*t + 2*v0)))/(aMin*jMax_jMax);

          IF ABS(orig) > 1E-9
          THEN
            deriv := (aMin - a0 - h1)*(h2 + h1*(4*a0 - aMin + 2*h1))/(aMin*jMax);
            
            IF ABS(deriv) > Constants.DoubleEpsilon
            THEN            
              t := t -orig / deriv;
            END_IF
          END_IF
        END_IF
      END_IF 
    END_IF  
	END_IF

  Profile.t[0] := t;
  Profile.t[1] := 0;
  Profile.t[2] := (a0 - aMin)/jMax + t;
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] :=  h3 - (2*a0 + jMax*t)*t/aMin;
  Profile.t[6] := (af - aMin)/jMax;
  
  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc1, jMax, vMax, vMin, aMax, aMin, setLimits:=TRUE))
  THEN
    AddProfile(Profile, jMax);
  END_IF
END_FOR   ]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_acc1_vel_two_step" Id="{64e54b1d-928d-4828-9fe0-4384e30cc74c}">
      <Declaration><![CDATA[METHOD PRIVATE time_acc1_vel_two_step
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[profile.t[0] := 0;
profile.t[1] := 0;
profile.t[2] := a0/jMax;
profile.t[3] := -(3*af_p4 - 8*aMin*(af_p3 - a0_p3) - 24*aMin*jMax*(a0*v0 - af*vf) + 6*af_af*(aMin*aMin - 2*jMax*vf) - 12*jMax*(2*aMin*jMax*pd + aMin*aMin*(vf + vMax) + jMax*(vMax*vMax - vf_vf) + aMin*a0*(a0_a0 - 2*jMax*(v0 + vMax))/jMax))/(24*aMin*jMax_jMax*vMax);
profile.t[4] := -aMin/jMax;
profile.t[5] := -(af_af/2 - aMin*aMin + jMax*(vMax - vf))/(aMin*jMax);
profile.t[6] := profile.t[4] + af/jMax;

IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc1Vel, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
THEN
  AddProfile(Profile, jMax);
  RETURN;        
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_all_vel" Id="{0932514e-6750-4a1f-b673-619a59e1903e}">
      <Declaration><![CDATA[METHOD PRIVATE time_all_vel
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ACC0_ACC1_VEL
Profile.t[0] := (-a0 + aMax)/jMax;
Profile.t[1] := (a0_a0*0.5 - aMax*aMax - jMax*(v0 - vMax))/(aMax*jMax);
Profile.t[2] := aMax/jMax;
Profile.t[3] := (3*(a0_p4*aMin - af_p4*aMax) + 8*aMax*aMin*(af_p3 - a0_p3 + 3*jMax*(a0*v0 - af*vf)) + 6*a0_a0*aMin*(aMax*aMax - 2*jMax*v0) - 6*af_af*aMax*(aMin*aMin - 2*jMax*vf) - 12*jMax*(aMax*aMin*(aMax*(v0 + vMax) - aMin*(vf + vMax) - 2*jMax*pd) + (aMin - aMax)*jMax*vMax*vMax + jMax*(aMax*vf_vf - aMin*v0_v0)))/(24*aMax*aMin*jMax_jMax*vMax);
Profile.t[4] := -aMin/jMax;
Profile.t[5] := -(af_af*0.5 - aMin*aMin - jMax*(vf - vMax))/(aMin*jMax);
Profile.t[6] := Profile.t[4] + af/jMax;

IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc0Acc1Vel, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
THEN
  AddProfile(Profile, jMax);
  RETURN;    
END_IF

// ACC1_VEL
t_acc0  := a0_a0/(2*jMax_jMax) + (vMax - v0)/jMax;
IF t_acc0 >= 0
THEN
  t_acc0 := SQRT(t_acc0 );
  Profile.t[0] := t_acc0  - a0/jMax;
  Profile.t[1] := 0;
  Profile.t[2] := t_acc0 ;
  Profile.t[3] := -(3*af_p4 - 8*aMin*(af_p3 - a0_p3) - 24*aMin*jMax*(a0*v0 - af*vf) + 6*af_af*(aMin*aMin - 2*jMax*vf) - 12*jMax*(2*aMin*jMax*pd + aMin*aMin*(vf + vMax) + jMax*(vMax*vMax - vf_vf) + aMin*t_acc0 *(a0_a0 - 2*jMax*(v0 + vMax))))/(24*aMin*jMax_jMax*vMax);
  //Profile.t[4] := -aMin/jMax;
  //Profile.t[5] := -(af_af*0.5 - aMin*aMin + jMax*(vMax - vf))/(aMin*jMax);
  //Profile.t[6] := Profile.t[4] + af/jMax;
        
  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc1Vel, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE)) 
  THEN
    AddProfile(Profile, jMax); 
    RETURN; 
  END_IF
END_IF

// ACC0_VEL
t_acc1 := 0.5*af_af/(jMax_jMax) + (vMax - vf)/jMax;
IF t_acc1 >= 0
THEN
  t_acc1 := SQRT(t_acc1);
  Profile.t[0] := (-a0 + aMax)/jMax;
  Profile.t[1] := (a0_a0*0.5 - aMax*aMax - jMax*(v0 - vMax))/(aMax*jMax);
  Profile.t[2] := aMax/jMax;
  Profile.t[3] := (3*a0_p4 + 8*(af_p3 - a0_p3)*aMax + 24*aMax*jMax*(a0*v0 - af*vf) + 6*a0_a0*(aMax*aMax - 2*jMax*v0) - 12*jMax*(-2*aMax*jMax*pd + aMax*aMax*(v0 + vMax) + jMax*(vMax*vMax - v0_v0) + (2*(vf + vMax)*jMax - af_af)*aMax*t_acc1))/(24*aMax*jMax_jMax*vMax);
  Profile.t[4] := t_acc1;
  Profile.t[5] := 0;
  Profile.t[6] := t_acc1 + af/jMax;
  
  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Acc0Vel, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE)) 
  THEN
    AddProfile(Profile, jMax);
    RETURN;
  END_IF
END_IF

// VEL
// Solution 3/4
IF t_acc0 >= 0 AND_THEN t_acc1 >= 0
THEN
  Profile.t[0] := t_acc0 - a0/jMax;
  Profile.t[1] := 0;
  Profile.t[2] := t_acc0;
  Profile.t[3] := (af_p3 - a0_p3)/(3.0*jMax_jMax*vMax) + (a0*v0 - af*vf + (af_af*t_acc1 + a0_a0*t_acc0)*0.5)/(jMax*vMax) - (v0/vMax + 1.0)*t_acc0 - (vf/vMax + 1.0)*t_acc1 + pd/vMax;
  //Profile.t[4] := t_acc1;
  //Profile.t[5] := 0;
  //Profile.t[6] := t_acc1 + af/jMax;
  
  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Vel, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN
    AddProfile(Profile, jMax);
    RETURN;
  END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_none" Id="{8dc73406-0d3d-47dc-bb3e-7f48cc7640c3}">
      <Declaration><![CDATA[METHOD PRIVATE time_none
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;  
  vMax : LREAL;
  vMin : LREAL;  
  aMax : LREAL;
  aMin : LREAL;
  jMax : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// UDDU
IF (ABS(v0) < Constants.DoubleEpsilon AND_THEN ABS(a0) < Constants.DoubleEpsilon AND_THEN ABS(vf) < Constants.DoubleEpsilon AND_THEN ABS(af) < Constants.DoubleEpsilon)
THEN
  Profile.t[0] := Cbrt(pd/(2*jMax));
  Profile.t[1] := 0;
  Profile.t[2] := 2*Profile.t[0];
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := Profile.t[0];
  
  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.None, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN
    AddProfile(Profile, jMax); 
  END_IF
  
  RETURN; 
END_IF

        
IF (ABS(a0 - af) < Constants.DoubleEpsilon AND_THEN ABS(v0 + vf) < Constants.DoubleEpsilon AND_THEN ABS(p0 - pf) < Constants.DoubleEpsilon) 
THEN
  h1 := SQRT(a0_a0 - 2*jMax*v0);

  // Solution 3
  Profile.t[0] := -(a0 + h1)/jMax;
  Profile.t[1] := 0;
  Profile.t[2] := Profile.t[0];
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := 0;

  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.None, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN
    AddProfile(Profile, jMax);                
  END_IF
        
  // Solution 4
  Profile.t[0] := -(a0 - h1)/jMax;
  Profile.t[1] := 0;
  Profile.t[2] := Profile.t[0];
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := 0;

  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.None, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN
    AddProfile(Profile, jMax);                
  END_IF
        
  RETURN;        
END_IF

// UDDU / UDUD modern, this one is in particular prone to numerical issues
// UDUD Strategy: t7 == 0 (equals UDDU)
h2 := (a0_a0 - af_af)/(2*jMax) + (vf - v0);
h2_h2 := h2*h2;
polynom[0] := 0.0;
polynom[1] := (-2*(a0_a0 + af_af - 2*jMax*(v0 + vf)))/jMax_jMax;
polynom[2] := 4*(a0_p3 - af_p3 + 3*jMax*(af*vf - a0*v0))/(3*jMax*jMax_jMax) - 4*pd/jMax;
polynom[3] := -h2_h2/jMax_jMax;

t_min := (a0 - af)/jMax;
t_max := (aMax - aMin)/jMax;
        
Roots.SolveQuartMonic(ADR(polynom), 4, rootCount:=rootCount, roots:=root);
FOR i:=0 TO rootCount
DO
  t := root[i];
  IF t < t_min OR_ELSE t > t_max
  THEN
    CONTINUE;
	END_IF
            
  // Single Newton-step (regarding pd)
  IF (t > Constants.DoubleEpsilon)
  THEN
    h1 := jMax*t*t;    
    orig := -h2_h2/(4*jMax*t) + h2*(af/jMax + t) + (4*a0_p3 + 2*af_p3 - 6*a0_a0*(af + 2*jMax*t) + 12*(af - a0)*jMax*v0 + 3*jMax_jMax*(-4*pd + (h1 + 8*v0)*t))/(12*jMax_jMax);
    deriv := h2 + 2*v0 - a0_a0/jMax + h2_h2/(4*h1) + (3*h1)/4;
    IF ABS(deriv) < Constants.DoubleEpsilon
    THEN
      CONTINUE;
    END_IF
    
    t := t - orig / deriv;
  END_IF
  
  IF (t <= Constants.DoubleEpsilon)
  THEN
    CONTINUE;
  END_IF
  
  h0 := h2/(2*jMax*t);
  Profile.t[0] := h0 + t*0.5 - a0/jMax;
  Profile.t[1] := 0;
  Profile.t[2] := t;
  Profile.t[3] := 0;
  Profile.t[4] := 0;
  Profile.t[5] := 0;
  Profile.t[6] := -h0 + t*0.5 + af/jMax;

  IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.None, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE)) 
  THEN
    AddProfile(Profile, jMax);            
  END_IF
  
END_FOR
        
    ]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_none_two_step" Id="{6056e359-3c2c-4ebb-b6ec-b0674ae1ae17}">
      <Declaration><![CDATA[METHOD PRIVATE time_none_two_step
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Two step
{}
  h0 := (a0_a0 + af_af)/2 + jMax*(vf - v0);
  IF h0 >= 0
  THEN
    h0 := SQRT(h0) * ABS(jMax) / jMax;
    profile.t[0] := (h0 - a0)/jMax;
    profile.t[1] := 0;
    profile.t[2] := (h0 - af)/jMax;
    profile.t[3] := 0;
    profile.t[4] := 0;
    profile.t[5] := 0;
    profile.t[6] := 0;
    
    IF (profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.None, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
    THEN 
      AddProfile(profile, jMax);
      RETURN;
    END_IF
	END_IF
{}
  
  // Single step
{}
  profile.t[0] := (af - a0)/jMax;
  profile.t[1] := 0;
  profile.t[2] := 0;
  profile.t[3] := 0;
  profile.t[4] := 0;
  profile.t[5] := 0;
  profile.t[6] := 0;
  
  IF (profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.None, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
  THEN 
    AddProfile(profile, jMax);
    RETURN;
  END_IF
{}]]></ST>
      </Implementation>
    </Method>
    <Method Name="time_vel_two_step" Id="{78d50b14-2a01-494d-b78f-ace6c4afe469}">
      <Declaration><![CDATA[METHOD PRIVATE time_vel_two_step
VAR_INPUT
  Profile : REFERENCE TO ProfileDesc;
  vMax, vMin, aMax, aMin, jMax : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[h1 := af_af/(2*jMax_jMax) + (vMax - vf)/jMax;

IF h1 >= 0
THEN
  h1 := SQRT(h1);
  
  // Four step
  {}    
    // Solution 3/4
    profile.t[0] := -a0/jMax;
    profile.t[1] := 0;
    profile.t[2] := 0;
    profile.t[3] := (af_p3 - a0_p3)/(3*jMax_jMax*vMax) + (a0*v0 - af*vf + (af_af*h1)/2)/(jMax*vMax) - (vf/vMax + 1.0)*h1 + pd/vMax;
    profile.t[4] := h1;
    profile.t[5] := 0;
    profile.t[6] := h1 + af/jMax;
  
    IF Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Vel, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE)
    THEN
      addProfile(profile, jMax);
      RETURN;
    END_IF 
  {}
  
  {}    
    // Four step        
    Profile.t[0] := 0;
    Profile.t[1] := 0;
    Profile.t[2] := a0/jMax;
    Profile.t[3] := (af_p3 - a0_p3)/(3.0*jMax_jMax*vMax) + (a0*v0 - af*vf + (af_af*h1 + a0_p3/jMax)*0.5)/(jMax*vMax) - (v0/vMax + 1.0)*a0/jMax - (vf/vMax + 1.0)*h1 + pd/vMax;
    Profile.t[4] := h1;
    Profile.t[5] := 0;
    Profile.t[6] := h1 + af/jMax;
    
    IF (Profile.CheckVel(ProfileJerkSigns.Uddu, ProfileLimits.Vel, jMax, vMax, vMin, aMax, aMin, setLimits:=FALSE))
    THEN
      AddProfile(Profile, jMax); 
      RETURN;       
    END_IF
  {}
END_IF]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>