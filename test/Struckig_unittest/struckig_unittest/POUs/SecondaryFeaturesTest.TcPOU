<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="SecondaryFeaturesTest" Id="{78a4d410-064c-404a-a1d2-ebb5b6bc814b}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK SecondaryFeaturesTest EXTENDS TcUnit.FB_TestSuite
VAR
  otg : Struckig.Ruckig(0.005);
  input : Struckig.InputParameter(3) := (
    Synchronization := SynchronizationType.None,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );
  output : Struckig.OutputParameter;  
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..2] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[Test_AtTime();
Test_FirstStateAtTime();
Test_IndependentMinDurations();
Test_InvalidInput();
Test_PositionExtrema();]]></ST>
    </Implementation>
    <Method Name="Test_AtTime" Id="{8747a524-a952-4b4b-9b1d-d5709bbaaf50}">
      <Declaration><![CDATA[METHOD Test_AtTime
VAR_INST
  otg : Struckig.Ruckig(0.005);
  input : Struckig.InputParameter(3) := (
    Synchronization := SynchronizationType.TimeSync,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );
  output : Struckig.OutputParameter;  
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('AtTime');
result := otg.update(input, output);

AssertEquals_INT(Expected := Struckig.TrajectoryState.busy, Actual := result, Message := '');
AssertEquals_LREAL(4.0, output.trajectory.duration, 1E-9, Message:='');

output.trajectory.atTime(0, 3, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration));
AssertArrayEquals_LREAL(input.CurrentPosition, NewPosition, 1E-9, message:='p(0) should be CurrentPosition');
AssertArrayEquals_LREAL(input.CurrentVelocity, NewVelocity, 1E-9, message:='v(0) should be CurrentVelocity');
AssertArrayEquals_LREAL(input.CurrentAcceleration, NewAcceleration, 1E-9, message:='a(0) should be CurrentAcceleration');

output.trajectory.atTime(output.trajectory.duration, 3, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration));
AssertArrayEquals_LREAL(input.TargetPosition, NewPosition, 1E-9, message:='p(0) should be TargetPosition');
AssertArrayEquals_LREAL(input.TargetVelocity, NewVelocity, 1E-9, message:='v(0) should be TargetVelocity');
AssertArrayEquals_LREAL(input.TargetAcceleration, NewAcceleration, 1E-9, message:='a(0) should be TargetAcceleration');

output.trajectory.atTime(2.0, 3, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration));
values[0] := 0.5;
values[1] := -2.6871268303;
values[2] := 1.0;
AssertArrayEquals_LREAL(values, NewPosition, 1E-9, message:='');

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_FirstStateAtTime" Id="{45288964-70c7-4f04-951a-1ad9938f231b}">
      <Declaration><![CDATA[METHOD Test_FirstStateAtTime
VAR_INST
  otg : Struckig.Ruckig(0.005);
  input : Struckig.InputParameter(3) := (
    Synchronization := SynchronizationType.TimeSync,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );
  output : Struckig.OutputParameter;  
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('FirstStateAtTime');

result := otg.update(input, output);

AssertTrue( output.trajectory.profiles[0].firstStateAtPosition(0.0, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(0.0, rtime, 1E-9, message:='');

AssertTrue( output.trajectory.profiles[0].firstStateAtPosition(0.5, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(2.0, rtime, 1E-9, message:='');

AssertTrue( output.trajectory.profiles[0].firstStateAtPosition(1.0, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(3.9999857615998957, rtime, 1E-9, message:=''); // doctest::Approx(4.0) 

AssertTrue( output.trajectory.profiles[1].firstStateAtPosition(-3.0, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(2.6004877902, rtime, 1E-9, message:='');

AssertTrue( output.trajectory.profiles[1].firstStateAtPosition(-3.1, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(2.8644154489, rtime, 1E-9, message:='');

AssertTrue( output.trajectory.profiles[2].firstStateAtPosition(0.05, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(0.6694329501, rtime, 1E-9, message:='');

AssertFalse( output.trajectory.profiles[0].firstStateAtPosition(-1.0, 0.0, rtime, rvel, racc), message:='' );
AssertFalse( output.trajectory.profiles[1].firstStateAtPosition(-3.4, 0.0, rtime, rvel, racc), message:='' );

// todo: this test doesn't make sense in the port of ruckig, the method is not exposed in the trajectory class yet
// AssertFalse( output.trajectory.profiles[6].firstStateAtPosition(6, 0.0, rtime, rvel, racc), message:='' );

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_IndependentMinDurations" Id="{a2e696c4-c9ef-4360-ab1b-ce079b7c502e}">
      <Declaration><![CDATA[METHOD Test_IndependentMinDurations
VAR_INST
  otg : Struckig.Ruckig(0.005);
  input : Struckig.InputParameter(3) := (
    Synchronization := SynchronizationType.None,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );
  output : Struckig.OutputParameter;  
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('IndependentMinDurations');

result := otg.update(input, output);

AssertEquals_LREAL(output.trajectory.independentMinDurations[0], 3.1748021039, 1E-9, message:='');
AssertEquals_LREAL(output.trajectory.independentMinDurations[1], 3.6860977315, 1E-9, message:='');
AssertEquals_LREAL(output.trajectory.independentMinDurations[2], output.trajectory.duration, 1E-9, message:='');

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_InvalidInput" Id="{7f2842b5-4b27-40e5-9e8d-50abf85326e8}">
      <Declaration><![CDATA[METHOD Test_InvalidInput
VAR_INST
  otg : Struckig.Ruckig(0.005);
  input : Struckig.InputParameter(3) := (
    Synchronization := SynchronizationType.None,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );
  output : Struckig.OutputParameter;  
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('InvalidInput');
result := otg.update(input, output); // first run

input.TargetVelocity[0] := 2.0;
input.TargetVelocity[1] := 0.3;
input.TargetVelocity[2] := 0.0;
result := otg.update(input, output);

AssertEquals_INT(result, Struckig.TrajectoryState.error, message:='State should be error');
AssertFalse(output.NewCalculation, message:='output.NewCalculation should be false');

input.TargetVelocity[0] := 0.2;
input.TargetVelocity[1] := -0.3;
input.TargetVelocity[2] := 0.8;
result := otg.update(input, output);

AssertEquals_INT(result, Struckig.TrajectoryState.busy, message:='State should be busy');
AssertTrue(output.NewCalculation, message:='output.NewCalculation should be true');

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_PositionExtrema" Id="{59aa613e-c11d-40bf-a12f-16c3c93702fe}">
      <Declaration><![CDATA[METHOD Test_PositionExtrema
VAR_INST
  otg : Struckig.Ruckig(0.005);
  input : Struckig.InputParameter(3) := (
    Synchronization := SynchronizationType.TimeSync,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );
  output : Struckig.OutputParameter;  
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('PositionExtrema');

result := otg.update(input, output);

positionExtrema := output.trajectory.profiles[0].positionExtrema();
AssertEquals_LREAL(4.0, positionExtrema.Tmax, 1E-9, message:='Profile[0] Tmax incorrect');
AssertEquals_LREAL(1.0, positionExtrema.Maximum, 1E-9, message:='Profile[0] maximum incorrect');
AssertEquals_LREAL(0.0, positionExtrema.Tmin, 1E-9, message:='Profile[0] Tmin incorrect');
AssertEquals_LREAL(0.0, positionExtrema.Minimum, 1E-9, message:='Profile[0] minimum incorrect');

positionExtrema := output.trajectory.profiles[1].positionExtrema();
AssertEquals_LREAL(0.0, positionExtrema.Tmax, 1E-9, message:='Profile[1] Tmax incorrect');
AssertEquals_LREAL(-2.0, positionExtrema.Maximum, 1E-9, message:='Profile[1] maximum incorrect');
AssertEquals_LREAL(3.2254033308, positionExtrema.Tmin, 1E-9, message:='Profile[1] Tmin incorrect');
AssertEquals_LREAL(-3.1549193338, positionExtrema.Minimum, 1E-9, message:='Profile[1] minimum incorrect');

positionExtrema := output.trajectory.profiles[2].positionExtrema();
AssertEquals_LREAL(4.0, positionExtrema.Tmax, 1E-9, message:='Profile[2] Tmax incorrect');
AssertEquals_LREAL(2.0, positionExtrema.Maximum, 1E-9, message:='Profile[2] maximum incorrect');
AssertEquals_LREAL(0.0, positionExtrema.Tmin, 1E-9, message:='Profile[2] Tmin incorrect');
AssertEquals_LREAL(0.0, positionExtrema.Minimum, 1E-9, message:='Profile[2] minimum incorrect');

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>