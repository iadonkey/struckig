<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="SecondaryFeaturesTest" Id="{78a4d410-064c-404a-a1d2-ebb5b6bc814b}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK SecondaryFeaturesTest EXTENDS TcUnit.FB_TestSuite
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..2] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL; 
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[Test_AtTime();
Test_FirstStateAtTime();
Test_IndependentMinDurations();
Test_InvalidInput();
Test_PerDofSettings();
Test_PhaseSynchronization();
Test_PositionExtrema();]]></ST>
    </Implementation>
    <Method Name="Test_AtTime" Id="{8747a524-a952-4b4b-9b1d-d5709bbaaf50}">
      <Declaration><![CDATA[METHOD Test_AtTime
VAR_INST
  otg : Struckig.Ruckig(0.005, 3) := (
  
    Synchronization := SynchronizationType.TimeSync,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );
   
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  NewSection : INT;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
	output: INT;
	trajectory: INT;
	atTime: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('AtTime');

otg();

AssertEquals_INT(Expected := Struckig.TrajectoryState.busy, Actual := otg.State, Message := '');
AssertEquals_LREAL(4.0, otg.Duration, 1E-9, Message:='');

otg.AtTime(0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
AssertArrayEquals_LREAL(otg.CurrentPosition, NewPosition, 1E-9, message:='p(0) should be CurrentPosition');
AssertArrayEquals_LREAL(otg.CurrentVelocity, NewVelocity, 1E-9, message:='v(0) should be CurrentVelocity');
AssertArrayEquals_LREAL(otg.CurrentAcceleration, NewAcceleration, 1E-9, message:='a(0) should be CurrentAcceleration');

otg.AtTime(otg.Duration, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
AssertArrayEquals_LREAL(otg.TargetPosition, NewPosition, 1E-9, message:='p(0) should be TargetPosition');
AssertArrayEquals_LREAL(otg.TargetVelocity, NewVelocity, 1E-9, message:='v(0) should be TargetVelocity');
AssertArrayEquals_LREAL(otg.TargetAcceleration, NewAcceleration, 1E-9, message:='a(0) should be TargetAcceleration');

otg.AtTime(2.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
values[0] := 0.5;
values[1] := -2.6871268303;
values[2] := 1.0;
AssertArrayEquals_LREAL(values, NewPosition, 1E-9, message:='');

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_FirstStateAtTime" Id="{45288964-70c7-4f04-951a-1ad9938f231b}">
      <Declaration><![CDATA[METHOD Test_FirstStateAtTime
VAR_INST
  otg : Struckig.Ruckig(0.005, 3) := (
  
    Synchronization := SynchronizationType.TimeSync,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );
    
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('FirstStateAtTime');

otg();

AssertTrue( otg._profiles[0].firstStateAtPosition(0.0, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(0.0, rtime, 1E-9, message:='');

AssertTrue( otg._profiles[0].firstStateAtPosition(0.5, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(2.0, rtime, 1E-9, message:='');

AssertTrue( otg._profiles[0].firstStateAtPosition(1.0, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(3.9999857615998957, rtime, 1E-9, message:=''); // doctest::Approx(4.0) 

AssertTrue( otg._profiles[1].firstStateAtPosition(-3.0, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(2.6004877902, rtime, 1E-9, message:='');

AssertTrue( otg._profiles[1].firstStateAtPosition(-3.1, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(2.8644154489, rtime, 1E-9, message:='');

AssertTrue( otg._profiles[2].firstStateAtPosition(0.05, 0.0, rtime, rvel, racc), message:='' );
AssertEquals_LREAL(0.6694329501, rtime, 1E-9, message:='');

AssertFalse( otg._profiles[0].firstStateAtPosition(-1.0, 0.0, rtime, rvel, racc), message:='' );
AssertFalse( otg._profiles[1].firstStateAtPosition(-3.4, 0.0, rtime, rvel, racc), message:='' );

// todo: this test doesn't make sense in the port of ruckig, the method is not exposed in the trajectory class yet
// AssertFalse( ruckig._profiles[6].firstStateAtPosition(6, 0.0, rtime, rvel, racc), message:='' );

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_IndependentMinDurations" Id="{a2e696c4-c9ef-4360-ab1b-ce079b7c502e}">
      <Declaration><![CDATA[METHOD Test_IndependentMinDurations
VAR_INST
  otg : Struckig.Ruckig(0.005, 3) := (
  
    Synchronization := SynchronizationType.None,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );
    
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('IndependentMinDurations');

otg();

AssertEquals_LREAL(otg._independentMinDurations[0], 3.1748021039, 1E-9, message:='');
AssertEquals_LREAL(otg._independentMinDurations[1], 3.6860977315, 1E-9, message:='');
AssertEquals_LREAL(otg._independentMinDurations[2], otg.Duration, 1E-9, message:='');

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_InvalidInput" Id="{7f2842b5-4b27-40e5-9e8d-50abf85326e8}">
      <Declaration><![CDATA[METHOD Test_InvalidInput
VAR_INST
  otg : Struckig.Ruckig(0.005, 3) := (
  
    Synchronization := SynchronizationType.None,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );
    
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('InvalidInput');

otg();

otg.TargetVelocity[0] := 2.0;
otg.TargetVelocity[1] := 0.3;
otg.TargetVelocity[2] := 0.0;

otg();

AssertEquals_INT(otg.State, Struckig.TrajectoryState.error, message:='State should be error');
AssertFalse(otg.NewCalculation, message:='ruckig.NewCalculation should be false');

otg.TargetVelocity[0] := 0.2;
otg.TargetVelocity[1] := -0.3;
otg.TargetVelocity[2] := 0.8;

otg();

AssertEquals_INT(otg.State, Struckig.TrajectoryState.busy, message:='State should be busy');
AssertTrue(otg.NewCalculation, message:='ruckig.NewCalculation should be true');

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_PerDofSettings" Id="{f04c0bef-a3eb-4d96-bb99-65b90fd47937}">
      <Declaration><![CDATA[METHOD Test_PerDofSettings
VAR_INST
  otg : Struckig.Ruckig(0.005, 3) := (
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    CurrentVelocity :=     [ 0.0, 0.0, 0.0 ],
    CurrentAcceleration := [ 0.0, 0.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    TargetAcceleration :=  [ 0.0, 0.0, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );
    
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  NewSection : INT;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('PerDofSettings');

otg();
AssertEquals_INT(otg.State, Struckig.TrajectoryState.Busy, message:='State should be busy');
AssertEquals_LREAL(otg.Duration, 4, 1E-6, message:='Duration not met');

otg.AtTime(2.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
values[0] := 0.5;
values[1] := -2.6871268303;
values[2] :=  1.0;
AssertArrayEquals_LREAL(values, NewPosition, 1E-6, message:='Position not met');


otg.ControlInterface := ControlInterfaceType.Velocity;
otg();
AssertEquals_INT(otg.State, Struckig.TrajectoryState.Busy, message:='State should be busy');
AssertEquals_LREAL(otg.Duration, 1.095445115, 1E-6, message:='Duration not met');

otg.AtTime(1.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
values[0] := 0.0;
values[1] := -1.8641718534;
values[2] :=  0.0;
AssertArrayEquals_LREAL(values, NewPosition, 1E-6, message:='Position not met');


otg.PerDofControlInterface[0] := ControlInterfaceType.Position;
otg.PerDofControlInterface[1] := ControlInterfaceType.Velocity;
otg.PerDofControlInterface[2] := ControlInterfaceType.Position;
otg();
AssertEquals_INT(otg.State, Struckig.TrajectoryState.Busy, message:='State should be busy');
AssertEquals_LREAL(otg.Duration, 4.0, 1E-6, message:='Duration not met');

otg.AtTime(2.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
values[0] := 0.5;
values[1] := -1.8528486838;
values[2] := 1.0;
AssertArrayEquals_LREAL(values, NewPosition, 1E-6, message:='Position not met');


otg.PerDofSynchronization[0] := SynchronizationType.TimeSync;
otg.PerDofSynchronization[1] := SynchronizationType.None;
otg.PerDofSynchronization[2] := SynchronizationType.TimeSync;
otg();
AssertEquals_INT(otg.State, Struckig.TrajectoryState.Busy, message:='State should be busy');
AssertEquals_LREAL(otg.Duration, 4.0, 1E-6, message:='Duration not met');

otg.AtTime(2.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
values[0] := 0.5;
values[1] := -1.5643167673;
values[2] := 1.0;
AssertArrayEquals_LREAL(values, NewPosition, 1E-6, message:='Position not met');

otg.ControlInterface := ControlInterfaceType.Position;
otg.PerDofControlInterface[0] := ControlInterfaceType.Undefined;
otg.PerDofControlInterface[1] := ControlInterfaceType.Undefined;
otg.PerDofControlInterface[2] := ControlInterfaceType.Undefined;
otg.PerDofSynchronization[0] := SynchronizationType.None;
otg.PerDofSynchronization[1] := SynchronizationType.TimeSync;
otg.PerDofSynchronization[2] := SynchronizationType.TimeSync;
otg();
AssertEquals_INT(otg.State, Struckig.TrajectoryState.Busy, message:='State should be busy');
AssertEquals_LREAL(otg.Duration, 4.0, 1E-6, message:='Duration not met');

otg.AtTime(2.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
values[0] := 0.7482143874;
values[1] := -2.6871268303;
values[2] := 1.0;
AssertArrayEquals_LREAL(values, NewPosition, 1E-6, message:='Position not met');

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_PhaseSynchronization" Id="{df39aa3d-ca70-4d91-9685-7c579cd985d7}">
      <Declaration><![CDATA[METHOD Test_PhaseSynchronization
VAR_INST
  otg : Struckig.Ruckig(0.005, 3) := (
    Synchronization := SynchronizationType.Phase,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  ); 
END_VAR
VAR
  result : Struckig.TrajectoryState;
  busy : Struckig.TrajectoryState := Struckig.TrajectoryState.Busy;
  NewSection : INT;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('PhaseSynchronization');

otg();
result := otg.State;
AssertEquals(busy, result, Message := '');
AssertEquals_LREAL(otg.Duration, 4.0, 1E-6, Message := ''); 
otg.AtTime(1.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
values[0] := 0.0833333333;
values[1] := -2.0833333333;
values[2] := 0.1666666667;
AssertArrayEquals_LREAL(values, NewPosition, 1E-6, '');




otg.CurrentPosition[0] := 0.0;
otg.CurrentPosition[1] := -2.0;
otg.CurrentPosition[2] := 0.0;

otg.TargetPosition[0] := 10.0;
otg.TargetPosition[1] := -3.0;
otg.TargetPosition[2] := 2.0;

otg.MaxVelocity[0] := 10.0;
otg.MaxVelocity[1] := 2.0;
otg.MaxVelocity[2] := 1.0;

otg.MaxAcceleration[0] := 10.0;
otg.MaxAcceleration[1] := 2.0;
otg.MaxAcceleration[2] := 1.0;

otg.MaxJerk[0] := 10.0;
otg.MaxJerk[1] := 2.0;
otg.MaxJerk[2] := 1.0;

otg();
result := otg.State;
AssertEquals(busy, result, Message := '');
AssertEquals_LREAL(otg.Duration, 4.0, 1E-6, Message := ''); 
otg.AtTime(1.0, ADR(NewPosition), ADR(NewVelocity), ADR(NewAcceleration), ADR(NewSection));
values[0] := 0.8333333333;
values[1] := -2.0833333333;
values[2] := 0.1666666667;
AssertArrayEquals_LREAL(values, NewPosition, 1E-6, '');

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Test_PositionExtrema" Id="{59aa613e-c11d-40bf-a12f-16c3c93702fe}">
      <Declaration><![CDATA[METHOD Test_PositionExtrema
VAR_INST
  otg : Struckig.Ruckig(0.005, 3) := (
    Synchronization := SynchronizationType.TimeSync,
    CurrentPosition :=     [ 0.0, -2.0, 0.0 ],
    TargetPosition :=      [ 1.0, -3.0, 2.0 ],
    TargetVelocity :=      [ 0.0, 0.3, 0.0 ],
    MaxVelocity :=         [ 1.0, 1.0, 1.0 ],
    MaxAcceleration :=     [ 1.0, 1.0, 1.0 ],
    MaxJerk :=             [ 1.0, 1.0, 1.0 ]
  );     
END_VAR
VAR
  result : Struckig.TrajectoryState;
  NewPosition, NewVelocity, NewAcceleration, values : ARRAY[0..Struckig.ParameterList.MaxDoFs] OF LREAL;
  positionExtrema : Struckig.PositionExtremaDesc;
  rtime, rvel, racc : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('PositionExtrema');

otg();

positionExtrema := otg._profiles[0].positionExtrema();
AssertEquals_LREAL(4.0, positionExtrema.Tmax, 1E-9, message:='Profile[0] Tmax incorrect');
AssertEquals_LREAL(1.0, positionExtrema.Maximum, 1E-9, message:='Profile[0] maximum incorrect');
AssertEquals_LREAL(0.0, positionExtrema.Tmin, 1E-9, message:='Profile[0] Tmin incorrect');
AssertEquals_LREAL(0.0, positionExtrema.Minimum, 1E-9, message:='Profile[0] minimum incorrect');

positionExtrema := otg._profiles[1].positionExtrema();
AssertEquals_LREAL(0.0, positionExtrema.Tmax, 1E-9, message:='Profile[1] Tmax incorrect');
AssertEquals_LREAL(-2.0, positionExtrema.Maximum, 1E-9, message:='Profile[1] maximum incorrect');
AssertEquals_LREAL(3.2254033308, positionExtrema.Tmin, 1E-9, message:='Profile[1] Tmin incorrect');
AssertEquals_LREAL(-3.1549193338, positionExtrema.Minimum, 1E-9, message:='Profile[1] minimum incorrect');

positionExtrema := otg._profiles[2].positionExtrema();
AssertEquals_LREAL(4.0, positionExtrema.Tmax, 1E-9, message:='Profile[2] Tmax incorrect');
AssertEquals_LREAL(2.0, positionExtrema.Maximum, 1E-9, message:='Profile[2] maximum incorrect');
AssertEquals_LREAL(0.0, positionExtrema.Tmin, 1E-9, message:='Profile[2] Tmin incorrect');
AssertEquals_LREAL(0.0, positionExtrema.Minimum, 1E-9, message:='Profile[2] minimum incorrect');

TEST_FINISHED();]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>